{"pages":[],"posts":[{"title":"DNF打造记录","text":"100级阿修罗装备附魔服务器: 跨六 价格日期: 2020年5月19日03:48:07 装备部位 附魔名称 附魔属性 获取方式 价格 头肩 天界支援兵 力50 智50 攻坚商店 反粒子35 上衣 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 下装 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 腰带 天界支援兵 力50 智50 攻坚商店 反粒子35 鞋 武器 孤独之拳凯芭朵娜 冰12 光12 拍卖 54w 手镯 维京首饰宝珠 光25 维京活动 维京硬币350 项链 维京首饰宝珠 光25 维京活动 维京硬币350 辅助装备 红腿爱克托 1级 物60 魔60 独60 拍卖 520w 戒指 维京首饰宝珠 光25 维京活动 维京硬币350 耳环 制造者卢克（光）上限 力智体精125 拍卖 1400w 魔法石 次元术士拉齐亚 上限 所有属强18 拍卖 310w 徽章镶嵌 装备部位 徽章颜色/个数 徽章属性 当前 目标 头肩 黄 2个 施放速度 1.6 1.6 上衣 绿 2个 智 魔爆 15 1.5 15 1.5 √ 下装 绿 2个 魔爆 2.2 15 1.5 15 1.5 腰带 红 2个 智 17 25 25 25 鞋 手镯 蓝2个 移速 1.1 1.1 项链 黄 2个 施放速度 1.6 1.6 辅助装备 白金 2个 无 意志白金 戒指 红 2个 智 17 17 25 25 魔法石 白金 2个 无 意志白金","link":"/2020/05/19/DNF%E6%89%93%E9%80%A0%E8%AE%B0%E5%BD%95/"},{"title":"Github Access Slow Solution","text":"win10系统： 编辑 C:\\Windows\\System32\\drivers\\etc\\hosts，添加内容： 12151.101.76.249 github.global-ssl.fastly.net 192.30.255.113 github.com","link":"/2020/04/11/Github-Access-Slow-Solution/"},{"title":"Linux Kernel Learning Dairy I","text":"1. GCC编译过程：预处理(pre-process): 预编译器(cpp)生成预编译后的源代码 -&gt; *.i 编译(compile): 编译器(ccl)生成汇编程序 -&gt; *.s 汇编(assemble): 汇编器(as)生成可重定位的目标程序 -&gt; *.o 链接(link): 链接器(ld)生成可执行二进制程序 -&gt; binary 2. Linux设备的三种类型a. 字符设备： 以字节为单位的 I/O 传输设备。如鼠标、键盘、触摸屏。 b. 块设备：以块为单位传输的设备。如磁盘。 c. 网络设备：网络协议相关设备。 3. 设备号主设备号（MAJOR）代表一类设备。 次设备号（MINOR）代表同一类设备的不同个体，每个次设备号都有一个不同的设备节点。","link":"/2020/06/14/Linux-Kernel-Learning-Dairy-I/"},{"title":"LeetCode Dairy I","text":"三数之和题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组 超时的解答：代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; vector&lt;int&gt; fine; sort(nums.begin(), nums.end()); map&lt;int, int&gt; restore_a; map&lt;int, int&gt;::iterator iter; int toFind; for(int i=0;i&lt;nums.size();i++){ iter = restore_a.find(nums[i]); if(iter != restore_a.end()){ continue; } restore_a[nums[i]] = 1; map&lt;int, int&gt; fmap; map&lt;int ,int&gt; restore_b; for(int j=i+1;j&lt;nums.size();j++){ toFind = (nums[i] + nums[j])* -1; iter = fmap.find(toFind); if(iter != fmap.end()){ iter = restore_b.find(nums[j]); if(iter != restore_b.end()){ continue; } restore_b[nums[j]] = 1; fine.clear(); fine.push_back(nums[i]); fine.push_back(nums[j]); fine.push_back(toFind); retSet.push_back(fine); } else{ fmap[nums[j]] = 1; } } } return retSet; }}; 参考双指针思路后的解答： 执行结果 用量 排名 用时 112ms 超过58.78% 内存 19.9MB 超过7.6% 代码实现（思路参考）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; if(nums.size() &lt; 3){ return retSet; } vector&lt;int&gt; bingo; sort(nums.begin(), nums.end()); int a_recent, b_recent, c_recent; for(int i=0;i&lt;nums.size()-2;i++){ if(nums[i]&gt;0){ break; } if(i&gt;0){ if(a_recent == nums[i]){ continue; } } a_recent = nums[i]; int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int sum = nums[i] + nums[j] + nums[k]; if(0 == sum){ bingo.clear(); bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); retSet.push_back(bingo); b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } if(sum &lt; 0){ b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } } if(sum &gt; 0){ c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } } } return retSet; }};","link":"/2020/07/04/LeetCode-Dairy-I/"},{"title":"LeetCode Dairy II","text":"1.最接近的三数之和题目描述：给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 通过解答： 执行结果 用量 排名 用时 16ms 超过65.7%用户 内存 10MB 超过7.14% 代码实现（原创）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { int ret; int min_distance; int first = 1; sort(nums.begin(), nums.end()); int len = nums.size(); int min = nums[0] + nums[1] + nums[2]; int max = nums[len - 1] + nums[len - 2] + nums[len - 3]; if(3 == nums.size()){ return min; } if(target &lt; min){ return min; } if(target &gt; max){ return max; } for(int i=0;i&lt;nums.size()-2;i++){ int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int distance = nums[i] + nums[j] + nums[k] - target; if(0 == distance){ return target; } if(first){ first = 0; min_distance = abs(distance); ret = target + distance; } if(abs(distance) &lt; min_distance){ min_distance = abs(distance); ret = target + distance; } if(distance &lt; 0){ j++; } if(distance &gt; 0){ k--; } } } return ret; }}; 电话号码的字母组合 NO. 17题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同） 通过解答： 执行结果 用量 排名 用时 0 ms 超过100% 内存 6.9 MB 超过100% 代码实现（原创）：123456789101112131415161718192021222324252627282930313233343536class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;vector&lt;string&gt;&gt; store = { {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, //2 {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;}, //3 {&quot;g&quot;, &quot;h&quot;, &quot;i&quot;}, //4 {&quot;j&quot;, &quot;k&quot;, &quot;l&quot;}, //5 {&quot;m&quot;, &quot;n&quot;, &quot;o&quot;}, //6 {&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;}, //7 {&quot;t&quot;, &quot;u&quot;, &quot;v&quot;}, //8 {&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;} //9 }; int len = digits.size(); vector&lt;string&gt; seed; if(!len){ return seed; } int index = 0; int numm = digits[index] - '0'; seed = store[numm - 2]; while(index &lt; len - 1){ vector&lt;string&gt; new_seed; for(int i = 0; i &lt; seed.size(); i++){ int num = digits[index + 1] - '0'; for(int j = 0; j &lt; store[num - 2].size(); j++){ string com = seed[i] + store[num - 2][j]; new_seed.push_back(com); } } seed = new_seed; index++; } return seed; }};","link":"/2020/07/05/LeetCode-Dairy-II/"},{"title":"斗鱼自动发弹幕js代码","text":"斗鱼循环发弹幕js代码：12345678910111213141516const area = document.getElementsByClassName('ChatSend-txt')[0]const btn = document.getElementsByClassName('ChatSend-button')[0]const danmu = '输入想发的弹幕内容'let intervalfunction start(){interval = setInterval(function(){area.value = danmubtn.click()},1000)}function stop(){clearInterval(interval)}start()","link":"/2020/06/06/%E6%96%97%E9%B1%BC%E8%87%AA%E5%8A%A8%E5%8F%91%E5%BC%B9%E5%B9%95js%E4%BB%A3%E7%A0%81/"},{"title":"LeetCode Dairy III","text":"四数之和 NO. 18题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 通过解答： 执行结果 用量 排名 用时 132ms 超过24.39%用户 内存 7.5MB 超过100% 代码实现（根据三数之和演变）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }}; 代码实现（参考边界判断思路的优化）： 执行结果 用量 排名 用时 16ms 超过90.03%用户 内存 7.4MB 超过100% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; if(nums[i] + nums[i + 1] * 3 &gt; target) break; //border if(nums[i] + nums[len - 1] * 3 &lt; target) continue; //border for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i] + nums[j] + nums[j + 1] * 2 &gt; target) break; //border if(nums[i] + nums[j] + nums[len - 1] * 2 &lt; target) continue; //border int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }};","link":"/2020/07/06/LeetCode-Dairy-III/"},{"title":"LeetCode Dairy IV","text":"删除链表的倒数第N个节点 NO.19题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 代码实现（原创，使用了哈希表）： 执行结果 用量 排名 用时 8ms 超过52.60%用户 内存 7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(n == 0){ return head; } map&lt;int, ListNode*&gt; store; map&lt;int, ListNode*&gt;::iterator iter; ListNode *cur = head; ListNode *ret = head; int index = 0; while(cur-&gt;next){ store[index] = cur; cur = cur-&gt;next; index++; } int len = index + 1; if(n &gt; len){ return NULL; } if(n == len){ //to free ret = head-&gt;next; delete(head); return ret; } int index_fo_find = len - n - 1; iter = store.find(index_fo_find); if(iter != store.end()){ ListNode* found = iter-&gt;second; ListNode* toFree = found-&gt;next; found-&gt;next = found-&gt;next-&gt;next; delete(toFree); } return ret; }}; 参考高速答案（双指针间隔n同步移动，实现如下）： 执行结果 用量 排名 用时 4ms 超过93.94%用户 内存 6.4MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(0 == n){ return head; } ListNode* pre = new ListNode(1); pre-&gt;next = head; ListNode* ptrA = pre; ListNode* ptrB = pre; int index = 0; int flag = 0; while(ptrB-&gt;next){ ptrB = ptrB-&gt;next; if(index == n){ flag = 1; } if(flag){ ptrA = ptrA-&gt;next; } index++; } if(!flag){ ListNode* ret = head; ListNode* toFree = head; ret = head-&gt;next; delete(toFree); delete(pre); return ret; } ListNode* toFree = ptrA-&gt;next; ptrA-&gt;next = ptrA-&gt;next-&gt;next; delete(toFree); delete(pre); return head; }}; 有效的括号 NO.20给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 代码实现（原创，栈）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.5MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: bool isValid(string s) { stack&lt;char&gt; stack; for(int i = 0;i &lt; s.size(); i++){ switch(s[i]){ case '(': case '{': case '[': { stack.push(s[i]); break; } case ')':{ if(!stack.empty() &amp;&amp; stack.top() == '('){ stack.pop(); } else{ return false; } break; } case '}':{ if(!stack.empty() &amp;&amp; stack.top() == '{'){ stack.pop(); } else{ return false; } break; } case ']':{ if(!stack.empty() &amp;&amp; stack.top() == '['){ stack.pop(); } else{ return false; } break; } default: return false; } } if(stack.empty()){ return true; } return false; }}; 合并两个有序链表 NO.21题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 代码实现（原创） 执行结果 用量 排名 用时 12ms 超过57.74%用户 内存 14.4MB 超过5.61%用户 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(); ListNode* head = l3; while(l1 &amp;&amp; l2){ if(l1-&gt;val &lt;= l2-&gt;val){ l3-&gt;next = l1; l3 = l3-&gt;next; l1 = l1-&gt;next; } else{ l3-&gt;next = l2; l3 = l3-&gt;next; l2 = l2-&gt;next; } } if(l1){ l3-&gt;next = l1; } if(l2){ l3-&gt;next = l2; } return head-&gt;next; }}; 代码实现（参考递归思想） 执行结果 用量 排名 用时 4ms 超过99.17%用户 内存 14.4MB 超过5.61%用户 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1){ return l2; } if(!l2){ return l1; } if(l1-&gt;val &lt;= l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else{ l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }};","link":"/2020/07/08/LeetCode-Dairy-IV/"},{"title":"LeetCode Dairy V","text":"括号生成 NO.22题目描述：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 代码实现（参考深度优先遍历答案）： 执行结果 用量 排名 用时 4ms 超过89.85%用户 内存 15.1MB 超过–%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; ret; string cur=&quot;&quot;; generate(cur, n, n, ret); return ret; } void generate(string current, int left, int right, vector&lt;string&gt; &amp;result){ if(left == 0 &amp;&amp; right == 0){ result.push_back(current); return; } if(left &gt; right){ return; } if(left &gt; 0){ generate(current + &quot;(&quot;, left - 1, right,result); } if(right &gt; 0){ generate(current + &quot;)&quot;, left, right - 1,result); } }}; 代码实现（参考动态规划思想）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 8.1MB 超过100%用户 1234567891011121314151617181920212223class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;vector&lt;string&gt;&gt; allset; allset.push_back({&quot;&quot;}); //for n = 0 allset.push_back({&quot;()&quot;}); //for n = 1 for(int i = 2; i &lt;= n; i++){ vector&lt;string&gt; newSet; for(int j = 0; j &lt; i; j++){ vector&lt;string&gt; setIn = allset[j]; vector&lt;string&gt; setOut = allset[i-1-j]; for(int k = 0; k &lt; setIn.size(); k++){ for(int l = 0; l &lt; setOut.size(); l++){ string newCombine = &quot;(&quot; + setIn[k] + &quot;)&quot; + setOut[l]; newSet.push_back(newCombine); } } } allset.push_back(newSet); } return allset[n]; }}; 删除排序数组中的重复项 NO.26题目描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 代码实现（原创，把不同的值直接按顺序覆盖数组的值） 执行结果 用量 排名 用时 8ms 超过99.99%用户 内存 7.5MB 超过100%用户 1234567891011121314151617181920class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int lastNum; int cur = 0; for(int i=0; i &lt; nums.size(); i++){ if(i &gt; 0){ if(nums[i] == lastNum){ continue; } nums[cur++] = nums[i]; } else{ cur++; } lastNum = nums[i]; } return cur; }};","link":"/2020/07/10/LeetCode-Dairy-V/"},{"title":"LeetCode Dairy VI","text":"移除元素 NO.27题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.2MB 超过100%用户 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int cur = 0; for(int i = 0;i &lt; nums.size(); i++){ if(nums[i] != val){ nums[cur++] = nums[i]; } } return cur; }}; 实现 strStr() NO.28题目描述：给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 代码实现（原创， 暴力解法）： 执行结果 用量 排名 用时 4ms 超过79.02%用户 内存 6.9MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int strStr(string haystack, string needle) { if(needle == &quot;&quot;){ return 0; } int pos = -1; int h_size = haystack.size(); int n_size = needle.size(); bool flag = 0; int needle_index = 0; for(int i = 0; i &lt; h_size;){ if(!flag &amp;&amp; haystack[i] == needle[needle_index]){ if(i + n_size &gt; h_size){ return -1; } flag = 1; pos = i; needle_index++; if(needle_index == n_size){ return pos; } i++; continue; } if(flag){ if(haystack[i] == needle[needle_index]){ needle_index++; i++; if(needle_index == n_size){ return pos; } continue; } else{ i = pos + 1; flag = 0; pos = -1; needle_index = 0; continue; } } i++; } return pos; }}; 代码实现（参考KMP算法实现，效率不理想）：思路总结： 构造dp数组，其中x记录的是当前状态包含的前缀，使用了类似双指针的方式构造，x在i指针左侧，与i指针共享判断字符j，当前j不满足x前进条件，则x会回退到0。 执行结果 用量 排名 用时 64ms 超过5.18%用户 内存 43.2MB 超过5.77%用户 1234567891011121314151617181920212223242526272829303132class Solution {public: int strStr(string haystack, string needle) { int nSize = needle.size(); int hSize = haystack.size(); int state = 0; if(!nSize){ return 0; } int dp[nSize][256]; memset(dp, 0, nSize*256); dp[0][needle[0]] = 1; int x = 0; for(int i = 1; i &lt; nSize; i++){ for(int j = 0; j &lt; 256; j++){ dp[i][j] = dp[x][j]; dp[i][needle[i]] = i + 1; } x = dp[x][needle[i]]; } for(int k = 0; k &lt; hSize; k++){ state = dp[state][haystack[k]]; if(state == nSize){ return k - nSize + 1; } } return -1; }}; 代码实现（参考SUNDAY算法思想，效率与暴力法相差无几）： 执行结果 用量 排名 用时 4ms 超过78.9%用户 内存 7.2MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334class Solution {public: int strStr(string haystack, string needle) { int hSize = haystack.size(); int nSize = needle.size(); if(!nSize){ return 0; } map&lt;char, int&gt; offsetMap; map&lt;char, int&gt;::iterator iter; for(int i =0 ;i &lt; nSize; i++){ offsetMap[needle[i]] = nSize - i; } for(int j=0; j&lt; hSize;){ if(j + nSize &gt; hSize){ return -1; } if(haystack.substr(j, nSize) == needle){ return j; } int tofind = j + nSize; iter = offsetMap.find(haystack[tofind]); if(iter != offsetMap.end()){ j += offsetMap[haystack[tofind]]; } else{ j += nSize + 1; } } return -1; }};","link":"/2020/07/11/LeetCode-Dairy-VI/"},{"title":"Algorithm Ideas","text":"算法解题思路：排序 哈希 双指针 值逼迫 边界判定 递归 深度优先遍历 动态规划 KMP","link":"/2020/07/11/Algorithm-Ideas/"},{"title":"LeetCode Dairy VII","text":"搜索插入位置 NO.35题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 代码实现（原创, 类似二分法）： 执行结果 用量 排名 用时 4ms 超过95.84%用户 内存 6.6MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize){ return 0; } int start = 0; int end = nSize - 1; if(target &lt;= nums[start]){ return 0; } if(target &gt; nums[end]){ return nSize; } int mid = (start + end)/2; while(end - start &gt; 1){ if(nums[mid] == target){ return mid; } if(nums[mid] &gt; target){ end = mid; } if(nums[mid] &lt; target){ start = mid; } mid = (start + end)/2; } return mid + 1; }}; 规范二分查找实现： 12345678910111213141516171819202122232425class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize){ return 0; } int start = 0; int end = nSize - 1; int mid = (start + end)/2; while(start &lt;= end){ if(nums[mid] == target){ return mid; } if(nums[mid] &gt; target){ end = mid - 1; } if(nums[mid] &lt; target){ start = mid + 1; } mid = (start + end)/2; } return start; }}; 外观数列 NO.38题目描述：给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。 注意：整数序列中的每一项将表示为一个字符串。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下： 1 11 21 1211 111221第一项是数字 1 描述前一项，这个数是 1 即 “一个 1 ”，记作 11 描述前一项，这个数是 11 即 “两个 1 ” ，记作 21 描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211 描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221 代码实现（原创, 非递归）： 执行结果 用量 排名 用时 4ms 超过84.94%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829class Solution {public: string countAndSay(int n) { string cur = &quot;1&quot;; for(int i = 2; i &lt; n + 1; i++){ string temp = &quot;&quot;; int index = 1; int cSize = cur.size(); char lastC = cur[0]; int count = 1; while(index &lt; cSize){ if(cur[index] == lastC){ count++; } else{ temp += to_string(count); temp.push_back(lastC); count = 1; } lastC = cur[index]; index++; } temp += to_string(count); temp.push_back(lastC); cur = temp; } return cur; }}; 代码实现（原创，递归）： 执行结果 用量 排名 用时 4ms 超过84.94%用户 内存 6.8MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: string countAndSay(int n) { if(n == 1){ return &quot;1&quot;; } string cur = countAndSay(n - 1); string temp = &quot;&quot;; int index = 1; int cSize = cur.size(); char lastC = cur[0]; int count = 1; while(index &lt; cSize){ if(cur[index] == lastC){ count++; } else{ temp += to_string(count); temp.push_back(lastC); count = 1; } lastC = cur[index]; index++; } temp += to_string(count); temp.push_back(lastC); cur = temp; return cur; }}; 两两交换链表中的节点 NO.24题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过65.97%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode *pre = new ListNode(1); pre-&gt;next = head; ListNode *newHead = pre; ListNode *cur = head; while(cur &amp;&amp; cur-&gt;next){ ListNode *afterNext = cur-&gt;next-&gt;next; pre-&gt;next = cur-&gt;next; cur-&gt;next = afterNext; pre-&gt;next-&gt;next = cur; pre = cur; cur = afterNext; } return newHead-&gt;next; }}; 代码实现（原创，递归） 执行结果 用量 排名 用时 4ms 超过65.97%用户 内存 6.5MB 超过100%用户 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { if(!head){ return NULL; } if(!head-&gt;next){ return head; } ListNode *nextHead = head-&gt;next-&gt;next; ListNode *temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; temp-&gt;next = head; head = temp; if(nextHead){ head-&gt;next-&gt;next = swapPairs(nextHead); } return head; }};","link":"/2020/07/13/LeetCode-Dairy-VII/"},{"title":"LeetCode Dairy VIII","text":"下一个排列 NO.31题目描述：实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过88.50%用户 内存 12.3MB 超过6.67%用户 1234567891011121314151617181920212223class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); for(int i = nSize - 1; i &gt;= 0 ; i--){ if(i - 1 &gt;=0 &amp;&amp; nums[i] &gt; nums[i-1]){ int toChange = i; for(int j = nSize - 1; j &gt;= i; j--){ if(nums[j] &gt; nums[i-1]){ toChange = j; break; } } int tmp = nums[i-1]; nums[i-1] = nums[toChange]; nums[toChange] = tmp; reverse(nums.begin() + i , nums.end()); return; } } sort(nums.begin(), nums.end()); }}; 搜索旋转排序数组 NO.33题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize) return -1; int start = 0; int end = nSize - 1; int mid = start + (end - start)/2; while(start &lt;= end){ if(nums[mid] == target){ return mid; } if(target &lt;= nums[end]){ if(nums[mid] &lt;= nums[end]){ if(target &lt; nums[mid]){ end = mid - 1; } else{ start = mid + 1; } } else{ start = mid + 1; } } else if(target &gt;= nums[start]){ if(nums[mid] &gt;= nums[start]){ if(target &lt; nums[mid]){ end = mid - 1; } else{ start = mid + 1; } } else{ end = mid - 1; } } else{ return -1; } mid = start + (end - start)/2; } return -1; }}; 在排序数组中查找元素的第一个和最后一个位置 NO.34题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 代码实现（原创）： 执行结果 用量 排名 用时 24ms 超过9.62%用户 内存 13.7MB 超过6.52%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ret; int nSize = nums.size(); int start = 0; int end = nSize - 1; int mid = start + (end - start)/2; int left = -1; int right = -1; int count = 0; int start_right = 0; int end_right = nSize - 1; while(start &lt;= end){ if(target == nums[mid]){ left = mid; end = mid - 1; } if(target &lt; nums[mid]){ end = mid - 1; } if(target &gt; nums[mid]){ start = mid + 1; } mid = start + (end - start)/2; } start = 0; end = nSize - 1; mid = start + (end - start)/2; while(start &lt;= end){ if(target == nums[mid]){ right = mid; start = mid + 1; } if(target &lt; nums[mid]){ end = mid - 1; } if(target &gt; nums[mid]){ start = mid + 1; } mid = start + (end - start)/2; } ret.push_back(left); ret.push_back(right); return ret; }};","link":"/2020/07/14/LeetCode-Dairy-VIII/"},{"title":"LeetCode Dairy IX","text":"有效的数独 NO.36题目描述：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 代码实现（原创, 暴力法）： 执行结果 用量 排名 用时 28ms 超过22.76%用户 内存 8.7MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { //row detect for(int i = 0; i &lt; 9; i++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int j = 0; j &lt; 9; j++){ if('.' == board[i][j]) continue; iter = detectMap.find(board[i][j]); if(iter != detectMap.end()){ return false; } detectMap[board[i][j]] = 1; } } //column detect for(int i = 0; i &lt; 9; i++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int j = 0; j &lt; 9; j++){ if('.' == board[j][i]) continue; iter = detectMap.find(board[j][i]); if(iter != detectMap.end()){ return false; } detectMap[board[j][i]] = 1; } } //3*3 detect for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int l = 0; l &lt; 3; l++){ for(int k=0; k &lt; 3; k++){ int x = 3*i + l; int y = 3*j + k; if('.' == board[x][y]) continue; iter = detectMap.find(board[x][y]); if(iter != detectMap.end()){ return false; } detectMap[board[x][y]] = 1; } } } } return true; }}; 代码实现（参考优化思路） 执行结果 用量 排名 用时 16ms 超过71.37%用户 内存 7.2MB 超过100%用户 123456789101112131415161718192021222324252627class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { int row[9][10] = {{0}}; int col[9][10] = {{0}}; int block[9][10] = {{0}}; for(int i = 0; i &lt; 9; i++){ for(int j = 0; j &lt; 9; j++){ int value = board[i][j]; if('.' == value) continue; value = value - '0'; if(row[i][value]) return false; row[i][value] = 1; if(col[j][value]) return false; col[j][value] = 1; int blockIndex = i/3 * 3 + j/3; if(block[blockIndex][value]) return false; block[blockIndex][value] = 1; } } return true; }}; 组合总和 NO.39题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 代码实现（参考深度优先遍历）： 执行结果 用量 排名 用时 40ms 超过21.36%用户 内存 14.2MB 超过18.64%用户 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; sort(candidates.begin(), candidates.end()); int index = 0; toFind(cur, candidates, target, ret, index); return ret; } void toFind(vector&lt;int&gt; current, vector&lt;int&gt; &amp;candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result, int left){ vector&lt;int&gt;::iterator iter; int index = left; for(iter = candidates.begin() + left; iter != candidates.end(); iter++){ if(*iter == target){ current.push_back(target); result.push_back(current); return; } if(*iter &lt; target){ vector&lt;int&gt; temp = current; temp.push_back(*iter); toFind(temp, candidates, target - *iter, result, index); } index++; } }}; 代码实现（细节优化，使用引用，减少拷贝） 执行结果 用量 排名 用时 8ms 超过83.29%用户 内存 10.8MB 超过33.90%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int index = 0; toFind(cur, candidates, target, ret, index); return ret; } void toFind(vector&lt;int&gt; &amp;current, vector&lt;int&gt; &amp;candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result, int left){ if(target == 0){ result.push_back(current); return; } if(target &lt; 0){ return; } for(int i = left; i &lt; candidates.size(); i++){ current.push_back(candidates[i]); toFind(current, candidates, target - candidates[i], result, i); current.pop_back(); } }};","link":"/2020/07/15/LeetCode-Dairy-IX/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"hard","slug":"hard","link":"/tags/hard/"}],"categories":[{"name":"game","slug":"game","link":"/categories/game/"},{"name":"tech","slug":"tech","link":"/categories/tech/"}]}
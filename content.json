{"pages":[],"posts":[{"title":"DNF打造记录","text":"100级阿修罗装备附魔服务器: 跨六 价格日期: 2020年5月19日03:48:07 装备部位 附魔名称 附魔属性 获取方式 价格 头肩 天界支援兵 力50 智50 攻坚商店 反粒子35 上衣 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 下装 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 腰带 天界支援兵 力50 智50 攻坚商店 反粒子35 鞋 武器 孤独之拳凯芭朵娜 冰12 光12 拍卖 54w 手镯 维京首饰宝珠 光25 维京活动 维京硬币350 项链 维京首饰宝珠 光25 维京活动 维京硬币350 辅助装备 红腿爱克托 1级 物60 魔60 独60 拍卖 520w 戒指 维京首饰宝珠 光25 维京活动 维京硬币350 耳环 制造者卢克（光）上限 力智体精125 拍卖 1400w 魔法石 次元术士拉齐亚 上限 所有属强18 拍卖 310w 徽章镶嵌 装备部位 徽章颜色/个数 徽章属性 当前 目标 头肩 黄 2个 施放速度 1.6 1.6 上衣 绿 2个 智 魔爆 15 1.5 15 1.5 √ 下装 绿 2个 魔爆 2.2 15 1.5 15 1.5 腰带 红 2个 智 17 25 25 25 鞋 手镯 蓝2个 移速 1.1 1.1 项链 黄 2个 施放速度 1.6 1.6 辅助装备 白金 2个 无 意志白金 戒指 红 2个 智 17 17 25 25 魔法石 白金 2个 无 意志白金","link":"/2020/05/19/DNF%E6%89%93%E9%80%A0%E8%AE%B0%E5%BD%95/"},{"title":"Github Access Slow Solution","text":"win10系统： 编辑 C:\\Windows\\System32\\drivers\\etc\\hosts，添加内容： 12151.101.76.249 github.global-ssl.fastly.net 192.30.255.113 github.com","link":"/2020/04/11/Github-Access-Slow-Solution/"},{"title":"Linux Kernel Learning Dairy I","text":"1. GCC编译过程：预处理(pre-process): 预编译器(cpp)生成预编译后的源代码 -&gt; *.i 编译(compile): 编译器(ccl)生成汇编程序 -&gt; *.s 汇编(assemble): 汇编器(as)生成可重定位的目标程序 -&gt; *.o 链接(link): 链接器(ld)生成可执行二进制程序 -&gt; binary 2. Linux设备的三种类型a. 字符设备： 以字节为单位的 I/O 传输设备。如鼠标、键盘、触摸屏。 b. 块设备：以块为单位传输的设备。如磁盘。 c. 网络设备：网络协议相关设备。 3. 设备号主设备号（MAJOR）代表一类设备。 次设备号（MINOR）代表同一类设备的不同个体，每个次设备号都有一个不同的设备节点。","link":"/2020/06/14/Linux-Kernel-Learning-Dairy-I/"},{"title":"LeetCode Dairy I","text":"三数之和题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组 超时的解答：代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; vector&lt;int&gt; fine; sort(nums.begin(), nums.end()); map&lt;int, int&gt; restore_a; map&lt;int, int&gt;::iterator iter; int toFind; for(int i=0;i&lt;nums.size();i++){ iter = restore_a.find(nums[i]); if(iter != restore_a.end()){ continue; } restore_a[nums[i]] = 1; map&lt;int, int&gt; fmap; map&lt;int ,int&gt; restore_b; for(int j=i+1;j&lt;nums.size();j++){ toFind = (nums[i] + nums[j])* -1; iter = fmap.find(toFind); if(iter != fmap.end()){ iter = restore_b.find(nums[j]); if(iter != restore_b.end()){ continue; } restore_b[nums[j]] = 1; fine.clear(); fine.push_back(nums[i]); fine.push_back(nums[j]); fine.push_back(toFind); retSet.push_back(fine); } else{ fmap[nums[j]] = 1; } } } return retSet; }}; 参考双指针思路后的解答： 执行结果 用量 排名 用时 112ms 超过58.78% 内存 19.9MB 超过7.6% 代码实现（思路参考）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; if(nums.size() &lt; 3){ return retSet; } vector&lt;int&gt; bingo; sort(nums.begin(), nums.end()); int a_recent, b_recent, c_recent; for(int i=0;i&lt;nums.size()-2;i++){ if(nums[i]&gt;0){ break; } if(i&gt;0){ if(a_recent == nums[i]){ continue; } } a_recent = nums[i]; int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int sum = nums[i] + nums[j] + nums[k]; if(0 == sum){ bingo.clear(); bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); retSet.push_back(bingo); b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } if(sum &lt; 0){ b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } } if(sum &gt; 0){ c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } } } return retSet; }};","link":"/2020/07/04/LeetCode-Dairy-I/"},{"title":"LeetCode Dairy II","text":"1.最接近的三数之和题目描述：给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 通过解答： 执行结果 用量 排名 用时 16ms 超过65.7%用户 内存 10MB 超过7.14% 代码实现（原创）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { int ret; int min_distance; int first = 1; sort(nums.begin(), nums.end()); int len = nums.size(); int min = nums[0] + nums[1] + nums[2]; int max = nums[len - 1] + nums[len - 2] + nums[len - 3]; if(3 == nums.size()){ return min; } if(target &lt; min){ return min; } if(target &gt; max){ return max; } for(int i=0;i&lt;nums.size()-2;i++){ int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int distance = nums[i] + nums[j] + nums[k] - target; if(0 == distance){ return target; } if(first){ first = 0; min_distance = abs(distance); ret = target + distance; } if(abs(distance) &lt; min_distance){ min_distance = abs(distance); ret = target + distance; } if(distance &lt; 0){ j++; } if(distance &gt; 0){ k--; } } } return ret; }}; 电话号码的字母组合 NO. 17题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同） 通过解答： 执行结果 用量 排名 用时 0 ms 超过100% 内存 6.9 MB 超过100% 代码实现（原创）：123456789101112131415161718192021222324252627282930313233343536class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;vector&lt;string&gt;&gt; store = { {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, //2 {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;}, //3 {&quot;g&quot;, &quot;h&quot;, &quot;i&quot;}, //4 {&quot;j&quot;, &quot;k&quot;, &quot;l&quot;}, //5 {&quot;m&quot;, &quot;n&quot;, &quot;o&quot;}, //6 {&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;}, //7 {&quot;t&quot;, &quot;u&quot;, &quot;v&quot;}, //8 {&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;} //9 }; int len = digits.size(); vector&lt;string&gt; seed; if(!len){ return seed; } int index = 0; int numm = digits[index] - '0'; seed = store[numm - 2]; while(index &lt; len - 1){ vector&lt;string&gt; new_seed; for(int i = 0; i &lt; seed.size(); i++){ int num = digits[index + 1] - '0'; for(int j = 0; j &lt; store[num - 2].size(); j++){ string com = seed[i] + store[num - 2][j]; new_seed.push_back(com); } } seed = new_seed; index++; } return seed; }};","link":"/2020/07/05/LeetCode-Dairy-II/"},{"title":"斗鱼自动发弹幕js代码","text":"斗鱼循环发弹幕js代码：12345678910111213141516const area = document.getElementsByClassName('ChatSend-txt')[0]const btn = document.getElementsByClassName('ChatSend-button')[0]const danmu = '输入想发的弹幕内容'let intervalfunction start(){interval = setInterval(function(){area.value = danmubtn.click()},1000)}function stop(){clearInterval(interval)}start()","link":"/2020/06/06/%E6%96%97%E9%B1%BC%E8%87%AA%E5%8A%A8%E5%8F%91%E5%BC%B9%E5%B9%95js%E4%BB%A3%E7%A0%81/"},{"title":"LeetCode Dairy III","text":"四数之和 NO. 18题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 通过解答： 执行结果 用量 排名 用时 132ms 超过24.39%用户 内存 7.5MB 超过100% 代码实现（根据三数之和演变）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }}; 代码实现（参考边界判断思路的优化）： 执行结果 用量 排名 用时 16ms 超过90.03%用户 内存 7.4MB 超过100% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; if(nums[i] + nums[i + 1] * 3 &gt; target) break; //border if(nums[i] + nums[len - 1] * 3 &lt; target) continue; //border for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i] + nums[j] + nums[j + 1] * 2 &gt; target) break; //border if(nums[i] + nums[j] + nums[len - 1] * 2 &lt; target) continue; //border int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }};","link":"/2020/07/06/LeetCode-Dairy-III/"},{"title":"LeetCode Dairy IV","text":"删除链表的倒数第N个节点 NO.19题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 代码实现（原创，使用了哈希表）： 执行结果 用量 排名 用时 8ms 超过52.60%用户 内存 7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(n == 0){ return head; } map&lt;int, ListNode*&gt; store; map&lt;int, ListNode*&gt;::iterator iter; ListNode *cur = head; ListNode *ret = head; int index = 0; while(cur-&gt;next){ store[index] = cur; cur = cur-&gt;next; index++; } int len = index + 1; if(n &gt; len){ return NULL; } if(n == len){ //to free ret = head-&gt;next; delete(head); return ret; } int index_fo_find = len - n - 1; iter = store.find(index_fo_find); if(iter != store.end()){ ListNode* found = iter-&gt;second; ListNode* toFree = found-&gt;next; found-&gt;next = found-&gt;next-&gt;next; delete(toFree); } return ret; }}; 参考高速答案（双指针间隔n同步移动，实现如下）： 执行结果 用量 排名 用时 4ms 超过93.94%用户 内存 6.4MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(0 == n){ return head; } ListNode* pre = new ListNode(1); pre-&gt;next = head; ListNode* ptrA = pre; ListNode* ptrB = pre; int index = 0; int flag = 0; while(ptrB-&gt;next){ ptrB = ptrB-&gt;next; if(index == n){ flag = 1; } if(flag){ ptrA = ptrA-&gt;next; } index++; } if(!flag){ ListNode* ret = head; ListNode* toFree = head; ret = head-&gt;next; delete(toFree); delete(pre); return ret; } ListNode* toFree = ptrA-&gt;next; ptrA-&gt;next = ptrA-&gt;next-&gt;next; delete(toFree); delete(pre); return head; }}; 有效的括号 NO.20给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 代码实现（原创，栈）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.5MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: bool isValid(string s) { stack&lt;char&gt; stack; for(int i = 0;i &lt; s.size(); i++){ switch(s[i]){ case '(': case '{': case '[': { stack.push(s[i]); break; } case ')':{ if(!stack.empty() &amp;&amp; stack.top() == '('){ stack.pop(); } else{ return false; } break; } case '}':{ if(!stack.empty() &amp;&amp; stack.top() == '{'){ stack.pop(); } else{ return false; } break; } case ']':{ if(!stack.empty() &amp;&amp; stack.top() == '['){ stack.pop(); } else{ return false; } break; } default: return false; } } if(stack.empty()){ return true; } return false; }}; 合并两个有序链表 NO.21题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 代码实现（原创） 执行结果 用量 排名 用时 12ms 超过57.74%用户 内存 14.4MB 超过5.61%用户 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(); ListNode* head = l3; while(l1 &amp;&amp; l2){ if(l1-&gt;val &lt;= l2-&gt;val){ l3-&gt;next = l1; l3 = l3-&gt;next; l1 = l1-&gt;next; } else{ l3-&gt;next = l2; l3 = l3-&gt;next; l2 = l2-&gt;next; } } if(l1){ l3-&gt;next = l1; } if(l2){ l3-&gt;next = l2; } return head-&gt;next; }}; 代码实现（参考递归思想） 执行结果 用量 排名 用时 4ms 超过99.17%用户 内存 14.4MB 超过5.61%用户 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1){ return l2; } if(!l2){ return l1; } if(l1-&gt;val &lt;= l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else{ l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }};","link":"/2020/07/08/LeetCode-Dairy-IV/"},{"title":"LeetCode Dairy V","text":"括号生成 NO.22题目描述：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 代码实现（参考深度优先遍历答案）： 执行结果 用量 排名 用时 4ms 超过89.85%用户 内存 15.1MB 超过–%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; ret; string cur=&quot;&quot;; generate(cur, n, n, ret); return ret; } void generate(string current, int left, int right, vector&lt;string&gt; &amp;result){ if(left == 0 &amp;&amp; right == 0){ result.push_back(current); return; } if(left &gt; right){ return; } if(left &gt; 0){ generate(current + &quot;(&quot;, left - 1, right,result); } if(right &gt; 0){ generate(current + &quot;)&quot;, left, right - 1,result); } }}; 代码实现（参考动态规划思想）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 8.1MB 超过100%用户 1234567891011121314151617181920212223class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;vector&lt;string&gt;&gt; allset; allset.push_back({&quot;&quot;}); //for n = 0 allset.push_back({&quot;()&quot;}); //for n = 1 for(int i = 2; i &lt;= n; i++){ vector&lt;string&gt; newSet; for(int j = 0; j &lt; i; j++){ vector&lt;string&gt; setIn = allset[j]; vector&lt;string&gt; setOut = allset[i-1-j]; for(int k = 0; k &lt; setIn.size(); k++){ for(int l = 0; l &lt; setOut.size(); l++){ string newCombine = &quot;(&quot; + setIn[k] + &quot;)&quot; + setOut[l]; newSet.push_back(newCombine); } } } allset.push_back(newSet); } return allset[n]; }}; 删除排序数组中的重复项 NO.26题目描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 代码实现（原创，把不同的值直接按顺序覆盖数组的值） 执行结果 用量 排名 用时 8ms 超过99.99%用户 内存 7.5MB 超过100%用户 1234567891011121314151617181920class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int lastNum; int cur = 0; for(int i=0; i &lt; nums.size(); i++){ if(i &gt; 0){ if(nums[i] == lastNum){ continue; } nums[cur++] = nums[i]; } else{ cur++; } lastNum = nums[i]; } return cur; }};","link":"/2020/07/10/LeetCode-Dairy-V/"},{"title":"LeetCode Dairy VI","text":"移除元素 NO.27题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.2MB 超过100%用户 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int cur = 0; for(int i = 0;i &lt; nums.size(); i++){ if(nums[i] != val){ nums[cur++] = nums[i]; } } return cur; }}; 实现 strStr() NO.28题目描述：给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 代码实现（原创， 暴力解法）： 执行结果 用量 排名 用时 4ms 超过79.02%用户 内存 6.9MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int strStr(string haystack, string needle) { if(needle == &quot;&quot;){ return 0; } int pos = -1; int h_size = haystack.size(); int n_size = needle.size(); bool flag = 0; int needle_index = 0; for(int i = 0; i &lt; h_size;){ if(!flag &amp;&amp; haystack[i] == needle[needle_index]){ if(i + n_size &gt; h_size){ return -1; } flag = 1; pos = i; needle_index++; if(needle_index == n_size){ return pos; } i++; continue; } if(flag){ if(haystack[i] == needle[needle_index]){ needle_index++; i++; if(needle_index == n_size){ return pos; } continue; } else{ i = pos + 1; flag = 0; pos = -1; needle_index = 0; continue; } } i++; } return pos; }}; 代码实现（参考KMP算法实现，效率不理想）：思路总结： 构造dp数组，其中x记录的是当前状态包含的前缀，使用了类似双指针的方式构造，x在i指针左侧，与i指针共享判断字符j，当前j不满足x前进条件，则x会回退到0。 执行结果 用量 排名 用时 64ms 超过5.18%用户 内存 43.2MB 超过5.77%用户 1234567891011121314151617181920212223242526272829303132class Solution {public: int strStr(string haystack, string needle) { int nSize = needle.size(); int hSize = haystack.size(); int state = 0; if(!nSize){ return 0; } int dp[nSize][256]; memset(dp, 0, nSize*256); dp[0][needle[0]] = 1; int x = 0; for(int i = 1; i &lt; nSize; i++){ for(int j = 0; j &lt; 256; j++){ dp[i][j] = dp[x][j]; dp[i][needle[i]] = i + 1; } x = dp[x][needle[i]]; } for(int k = 0; k &lt; hSize; k++){ state = dp[state][haystack[k]]; if(state == nSize){ return k - nSize + 1; } } return -1; }}; 代码实现（参考SUNDAY算法思想，效率与暴力法相差无几）： 执行结果 用量 排名 用时 4ms 超过78.9%用户 内存 7.2MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334class Solution {public: int strStr(string haystack, string needle) { int hSize = haystack.size(); int nSize = needle.size(); if(!nSize){ return 0; } map&lt;char, int&gt; offsetMap; map&lt;char, int&gt;::iterator iter; for(int i =0 ;i &lt; nSize; i++){ offsetMap[needle[i]] = nSize - i; } for(int j=0; j&lt; hSize;){ if(j + nSize &gt; hSize){ return -1; } if(haystack.substr(j, nSize) == needle){ return j; } int tofind = j + nSize; iter = offsetMap.find(haystack[tofind]); if(iter != offsetMap.end()){ j += offsetMap[haystack[tofind]]; } else{ j += nSize + 1; } } return -1; }};","link":"/2020/07/11/LeetCode-Dairy-VI/"},{"title":"Algorithm Ideas","text":"算法解题思路：排序 哈希 双指针 值逼迫 边界判定 递归 深度优先遍历 动态规划 KMP","link":"/2020/07/11/Algorithm-Ideas/"},{"title":"LeetCode Dairy VII","text":"搜索插入位置 NO.35题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 代码实现（原创, 类似二分法）： 执行结果 用量 排名 用时 4ms 超过95.84%用户 内存 6.6MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize){ return 0; } int start = 0; int end = nSize - 1; if(target &lt;= nums[start]){ return 0; } if(target &gt; nums[end]){ return nSize; } int mid = (start + end)/2; while(end - start &gt; 1){ if(nums[mid] == target){ return mid; } if(nums[mid] &gt; target){ end = mid; } if(nums[mid] &lt; target){ start = mid; } mid = (start + end)/2; } return mid + 1; }}; 规范二分查找实现： 12345678910111213141516171819202122232425class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize){ return 0; } int start = 0; int end = nSize - 1; int mid = (start + end)/2; while(start &lt;= end){ if(nums[mid] == target){ return mid; } if(nums[mid] &gt; target){ end = mid - 1; } if(nums[mid] &lt; target){ start = mid + 1; } mid = (start + end)/2; } return start; }}; 外观数列 NO.38题目描述：给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。 注意：整数序列中的每一项将表示为一个字符串。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下： 1 11 21 1211 111221第一项是数字 1 描述前一项，这个数是 1 即 “一个 1 ”，记作 11 描述前一项，这个数是 11 即 “两个 1 ” ，记作 21 描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211 描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221 代码实现（原创, 非递归）： 执行结果 用量 排名 用时 4ms 超过84.94%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829class Solution {public: string countAndSay(int n) { string cur = &quot;1&quot;; for(int i = 2; i &lt; n + 1; i++){ string temp = &quot;&quot;; int index = 1; int cSize = cur.size(); char lastC = cur[0]; int count = 1; while(index &lt; cSize){ if(cur[index] == lastC){ count++; } else{ temp += to_string(count); temp.push_back(lastC); count = 1; } lastC = cur[index]; index++; } temp += to_string(count); temp.push_back(lastC); cur = temp; } return cur; }}; 代码实现（原创，递归）： 执行结果 用量 排名 用时 4ms 超过84.94%用户 内存 6.8MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: string countAndSay(int n) { if(n == 1){ return &quot;1&quot;; } string cur = countAndSay(n - 1); string temp = &quot;&quot;; int index = 1; int cSize = cur.size(); char lastC = cur[0]; int count = 1; while(index &lt; cSize){ if(cur[index] == lastC){ count++; } else{ temp += to_string(count); temp.push_back(lastC); count = 1; } lastC = cur[index]; index++; } temp += to_string(count); temp.push_back(lastC); cur = temp; return cur; }}; 两两交换链表中的节点 NO.24题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过65.97%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode *pre = new ListNode(1); pre-&gt;next = head; ListNode *newHead = pre; ListNode *cur = head; while(cur &amp;&amp; cur-&gt;next){ ListNode *afterNext = cur-&gt;next-&gt;next; pre-&gt;next = cur-&gt;next; cur-&gt;next = afterNext; pre-&gt;next-&gt;next = cur; pre = cur; cur = afterNext; } return newHead-&gt;next; }}; 代码实现（原创，递归） 执行结果 用量 排名 用时 4ms 超过65.97%用户 内存 6.5MB 超过100%用户 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { if(!head){ return NULL; } if(!head-&gt;next){ return head; } ListNode *nextHead = head-&gt;next-&gt;next; ListNode *temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; temp-&gt;next = head; head = temp; if(nextHead){ head-&gt;next-&gt;next = swapPairs(nextHead); } return head; }};","link":"/2020/07/13/LeetCode-Dairy-VII/"},{"title":"LeetCode Dairy VIII","text":"下一个排列 NO.31题目描述：实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过88.50%用户 内存 12.3MB 超过6.67%用户 1234567891011121314151617181920212223class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); for(int i = nSize - 1; i &gt;= 0 ; i--){ if(i - 1 &gt;=0 &amp;&amp; nums[i] &gt; nums[i-1]){ int toChange = i; for(int j = nSize - 1; j &gt;= i; j--){ if(nums[j] &gt; nums[i-1]){ toChange = j; break; } } int tmp = nums[i-1]; nums[i-1] = nums[toChange]; nums[toChange] = tmp; reverse(nums.begin() + i , nums.end()); return; } } sort(nums.begin(), nums.end()); }}; 搜索旋转排序数组 NO.33题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize) return -1; int start = 0; int end = nSize - 1; int mid = start + (end - start)/2; while(start &lt;= end){ if(nums[mid] == target){ return mid; } if(target &lt;= nums[end]){ if(nums[mid] &lt;= nums[end]){ if(target &lt; nums[mid]){ end = mid - 1; } else{ start = mid + 1; } } else{ start = mid + 1; } } else if(target &gt;= nums[start]){ if(nums[mid] &gt;= nums[start]){ if(target &lt; nums[mid]){ end = mid - 1; } else{ start = mid + 1; } } else{ end = mid - 1; } } else{ return -1; } mid = start + (end - start)/2; } return -1; }}; 在排序数组中查找元素的第一个和最后一个位置 NO.34题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 代码实现（原创）： 执行结果 用量 排名 用时 24ms 超过9.62%用户 内存 13.7MB 超过6.52%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ret; int nSize = nums.size(); int start = 0; int end = nSize - 1; int mid = start + (end - start)/2; int left = -1; int right = -1; int count = 0; int start_right = 0; int end_right = nSize - 1; while(start &lt;= end){ if(target == nums[mid]){ left = mid; end = mid - 1; } if(target &lt; nums[mid]){ end = mid - 1; } if(target &gt; nums[mid]){ start = mid + 1; } mid = start + (end - start)/2; } start = 0; end = nSize - 1; mid = start + (end - start)/2; while(start &lt;= end){ if(target == nums[mid]){ right = mid; start = mid + 1; } if(target &lt; nums[mid]){ end = mid - 1; } if(target &gt; nums[mid]){ start = mid + 1; } mid = start + (end - start)/2; } ret.push_back(left); ret.push_back(right); return ret; }};","link":"/2020/07/14/LeetCode-Dairy-VIII/"},{"title":"LeetCode Dairy IX","text":"有效的数独 NO.36题目描述：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 代码实现（原创, 暴力法）： 执行结果 用量 排名 用时 28ms 超过22.76%用户 内存 8.7MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { //row detect for(int i = 0; i &lt; 9; i++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int j = 0; j &lt; 9; j++){ if('.' == board[i][j]) continue; iter = detectMap.find(board[i][j]); if(iter != detectMap.end()){ return false; } detectMap[board[i][j]] = 1; } } //column detect for(int i = 0; i &lt; 9; i++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int j = 0; j &lt; 9; j++){ if('.' == board[j][i]) continue; iter = detectMap.find(board[j][i]); if(iter != detectMap.end()){ return false; } detectMap[board[j][i]] = 1; } } //3*3 detect for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int l = 0; l &lt; 3; l++){ for(int k=0; k &lt; 3; k++){ int x = 3*i + l; int y = 3*j + k; if('.' == board[x][y]) continue; iter = detectMap.find(board[x][y]); if(iter != detectMap.end()){ return false; } detectMap[board[x][y]] = 1; } } } } return true; }}; 代码实现（参考优化思路） 执行结果 用量 排名 用时 16ms 超过71.37%用户 内存 7.2MB 超过100%用户 123456789101112131415161718192021222324252627class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { int row[9][10] = {{0}}; int col[9][10] = {{0}}; int block[9][10] = {{0}}; for(int i = 0; i &lt; 9; i++){ for(int j = 0; j &lt; 9; j++){ int value = board[i][j]; if('.' == value) continue; value = value - '0'; if(row[i][value]) return false; row[i][value] = 1; if(col[j][value]) return false; col[j][value] = 1; int blockIndex = i/3 * 3 + j/3; if(block[blockIndex][value]) return false; block[blockIndex][value] = 1; } } return true; }}; 组合总和 NO.39题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 代码实现（参考深度优先遍历）： 执行结果 用量 排名 用时 40ms 超过21.36%用户 内存 14.2MB 超过18.64%用户 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; sort(candidates.begin(), candidates.end()); int index = 0; toFind(cur, candidates, target, ret, index); return ret; } void toFind(vector&lt;int&gt; current, vector&lt;int&gt; &amp;candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result, int left){ vector&lt;int&gt;::iterator iter; int index = left; for(iter = candidates.begin() + left; iter != candidates.end(); iter++){ if(*iter == target){ current.push_back(target); result.push_back(current); return; } if(*iter &lt; target){ vector&lt;int&gt; temp = current; temp.push_back(*iter); toFind(temp, candidates, target - *iter, result, index); } index++; } }}; 代码实现（细节优化，使用引用，减少拷贝） 执行结果 用量 排名 用时 8ms 超过83.29%用户 内存 10.8MB 超过33.90%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int index = 0; toFind(cur, candidates, target, ret, index); return ret; } void toFind(vector&lt;int&gt; &amp;current, vector&lt;int&gt; &amp;candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result, int left){ if(target == 0){ result.push_back(current); return; } if(target &lt; 0){ return; } for(int i = left; i &lt; candidates.size(); i++){ current.push_back(candidates[i]); toFind(current, candidates, target - candidates[i], result, i); current.pop_back(); } }};","link":"/2020/07/15/LeetCode-Dairy-IX/"},{"title":"LeetCode Dairy X","text":"组合总和 II NO.40题目描述：给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 代码实现（原创）： 执行结果 用量 排名 用时 8ms 超过78.29%用户 内存 7.1MB 超过100%用户 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; sort(candidates.begin(), candidates.end()); toFind(cur, candidates, target, ret,0); return ret; } void toFind(vector&lt;int&gt; &amp;current, vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result,int left){ if(target == 0){ result.push_back(current); return; } if(target &lt; 0) return; int count = 0; for(int i = left; i &lt; candidates.size(); i++){ if(count &amp;&amp; candidates[i] == candidates[i - 1]){ continue; } current.push_back(candidates[i]); toFind(current, candidates, target - candidates[i], result, i + 1); current.pop_back(); count++; } }}; 全排列 NO.46题目描述：给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过88.91%用户 内存 7.4MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int fg[nums.size()]; memset(fg, 0, nums.size() * sizeof(int)); toFind(cur, nums, ret, fg); return ret; } void toFind(vector&lt;int&gt;&amp; current, vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, int *flag){ if(current.size() == nums.size()){ result.push_back(current); return; } for(int i = 0; i&lt;nums.size(); i++){ if(flag[i]){ continue; } current.push_back(nums[i]); flag[i] = 1; toFind(current, nums, result, flag); current.pop_back(); flag[i] = 0; } }}; 全排列 II NO.47题目描述：给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 代码实现（原创，多次递归不选相同下标，同一次递归内不选取相同值的元素）： 执行结果 用量 排名 用时 4ms 超过99.25%用户 内存 7.7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int nSize = nums.size(); char fg[nSize]; memset(fg, 0, nSize); sort(nums.begin(), nums.end()); toFind(cur, nums, ret, fg); return ret; } void toFind(vector&lt;int&gt;&amp; current, vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, char* flag){ if(current.size() == nums.size()){ result.push_back(current); return; } int count = 0; int lastIn; for(int i = 0; i &lt; nums.size(); i++){ if(flag[i]) continue; if(count &amp;&amp; nums[i] == lastIn) continue; lastIn = nums[i]; current.push_back(nums[i]); flag[i] = 1; toFind(current, nums, result, flag); current.pop_back(); flag[i] = 0; count++; } }}; 字符串相乘 NO.43题目描述：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = “2”, num2 = “3”输出: “6”示例 2: 输入: num1 = “123”, num2 = “456”输出: “56088”说明： num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 代码实现（原创，暴力法）： 执行结果 用量 排名 用时 64ms 超过16.21%用户 内存 11.5MB 超过25.93%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution {public: string multiply(string num1, string num2) { int nSize1 = num1.size(); int nSize2 = num2.size(); if(!nSize1 || !nSize1) return &quot;&quot;; if(nSize1 == 1 &amp;&amp; num1 == &quot;0&quot;){ return &quot;0&quot;; } if(nSize2 == 1 &amp;&amp; num2 == &quot;0&quot;){ return &quot;0&quot;; } string seed = &quot;&quot;; for(int i = nSize1 - 1; i &gt;=0; i--){ char multiSeed = 0; string temp = &quot;&quot;; for(int j = nSize2 - 1; j &gt;= 0; j--){ char multi = (num1[i] - '0') * (num2[j] - '0') + multiSeed; multiSeed = multi / 10; temp.push_back(multi % 10 + '0'); } if(multiSeed){ temp.push_back(multiSeed + '0'); } reverse(temp.begin(), temp.end()); for(int k = 0; k &lt; nSize1 - 1 - i; k++){ temp.push_back('0'); } seed = sum(seed, temp); } return seed; } string sum(string n1, string n2){ int index1 = n1.size() - 1; int index2 = n2.size() - 1; int up = 0; string store = &quot;&quot;; while(index1 &gt;=0 || index2 &gt;= 0){ char p1, p2; if(index1 &gt;=0){ p1 = n1[index1] - '0'; index1--; } else{ p1 = 0; } if(index2 &gt;= 0){ p2 = n2[index2] - '0'; index2--; } else{ p2 = 0; } char s = p1 + p2 + up; if(s &gt;= 10){ s -= 10; up = 1; } else{ up = 0; } store.push_back(s + '0'); } if(up){ store.push_back('1'); } reverse(store.begin(), store.end()); return store; }}; 代码实现（参考优化竖式思路）两个数，N1长度为n，N2长度为m，相乘之后，最大总位数为m+n 执行结果 用量 排名 用时 4ms 超过98.89%用户 内存 6.5MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536class Solution {public: string multiply(string num1, string num2) { int size1 = num1.size(); int size2 = num2.size(); if(size1 == 1 &amp;&amp; num1 == &quot;0&quot;){ return &quot;0&quot;; } if(size2 == 1 &amp;&amp; num2 == &quot;0&quot;){ return &quot;0&quot;; } reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); string result = &quot;&quot;; vector&lt;char&gt; store(size1 + size2, 0); char up = 0; for(int i = 0;i &lt; size1; i++){ for(int j = 0;j &lt; size2; j++){ char multi = (num1[i] - '0') * (num2[j] - '0') + store[i + j]; char one = multi % 10; char ten = multi / 10; store[i+j] = one; store[i+j+1] += ten; } } int flag = 1; for(int k = size1 + size2 - 1; k &gt;= 0; k--){ if(flag &amp;&amp; store[k] == 0){ continue; } flag = 0; result.push_back(store[k] + '0'); } return result; }};","link":"/2020/07/16/LeetCode-Dairy-X/"},{"title":"LeetCode Dairy XI","text":"旋转图像 NO.48题目描述：给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix =[ [1,2,3], [4,5,6], [7,8,9]], 原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 代码实现（原创，先逆置，再调转）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.2MB 超过100%用户 123456789101112131415161718class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0;i &lt; n; i++){ for(int j = 0;j &lt; n;j++){ if(i &lt; j){ int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } } for(int k = 0; k &lt; n; k++){ reverse(matrix[k].begin(), matrix[k].end()); } }}; 代码实现（参考以四个点为单位旋转，寻找四个点关系的思想）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.3MB 超过100%用户 123456789101112131415class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0; i &lt; n/2; i++){ for(int j = i; j &lt; n- 1 -i; j++){ int temp = matrix[i][j]; matrix[i][j] = matrix[n - 1 - j][i]; matrix[n - 1 -j ][i] = matrix[n - 1 -i][n - 1 -j]; matrix[n - 1 -i][n - 1 -j] = matrix[j][n-1-i]; matrix[j][n-1-i] = temp; } } }}; 代码实现（参考运动轨迹思想）： 执行结果 用量 排名 用时 4 ms 超过61.25%用户 内存 7.2MB 超过100%用户 123456789101112131415161718192021222324class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); int stepSub = n - 1; int stepPlus = 0; while(stepSub &gt;= stepPlus){ int start = stepPlus; int end = stepSub; while(start != stepSub){ int temp = matrix[stepPlus][start]; matrix[stepPlus][start] = matrix[end][stepPlus]; matrix[end][stepPlus] = matrix[stepSub][end]; matrix[stepSub][end] = matrix[start][stepSub]; matrix[start][stepSub] = temp; end--; start++; } stepSub--; stepPlus++; } }};","link":"/2020/07/17/LeetCode-Dairy-XI/"},{"title":"LeetCode Dairy XII","text":"两数相除 NO.29题目描述：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。 代码实现（原创，将被除数和除数都转换成负数，防止越界，c++ 负数不能左移，先转换成无符号整型）： 执行结果 用量 排名 用时 4ms 超过60.71%用户 内存 5.8MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution {public: int divide(int dividend, int divisor) { int sign = 1; int ret = 0; if(divisor &lt; 0){ sign = 0 - sign; } else{ divisor = 0 - divisor; } if(dividend &lt; 0){ sign = 0 - sign; } else{ dividend = 0 - dividend; } int end = dividend; int seed = divisor; int count = 0; int overflow = 0; while( seed &gt;= end){ while(seed &gt;= end){ if(seed &lt;= INT_MIN&gt;&gt;1){ if(!count){ overflow = 1; count++; } break; } seed = (unsigned int)seed&lt;&lt;1; count++; } if(count) { ret -= 1&lt;&lt;(count - 1); } int last_value; if(!overflow){ last_value = seed&gt;&gt;1; } else{ last_value = seed; } end = end - last_value; seed = divisor; count = 0; } if(sign &lt; 0){ return ret; } else{ if(ret == INT_MIN){ return INT_MAX; } return 0 - ret; } }}; 代码实现（参考不用位操作的递归思想） 执行结果 用量 排名 用时 0ms 超过100%用户 内存 5.9MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution {public: int divide(int dividend, int divisor) { int ret = 0; int count = 0; int sign = 1; if(dividend &lt; 0){ sign = 0 - sign; } else{ dividend = 0 - dividend; } if(divisor &lt; 0){ sign = 0 - sign; } else{ divisor = 0 - divisor; } div(dividend, divisor, divisor, count, ret); if(sign &gt; 0){ if(ret == INT_MIN){ return INT_MAX; } else{ return 0 - ret; } } return ret; } void div(int dividend, int divisor, int sor, int count,int &amp;result){ if(dividend &gt; divisor){ return; } if(dividend == divisor){ result--; return; } int toClose; int overflow = 0; if(sor &lt; INT_MIN&gt;&gt;1){ overflow = 1; toClose = sor; } else{ toClose = sor + sor; } if(!overflow &amp;&amp; toClose &gt; dividend){ if(!count) { count = 1; } count = count + count; div(dividend, divisor, toClose, count, result); } if(overflow || toClose &lt;= dividend){ if(!count){ result -= 1; } else{ result -= count; } count = 0; div(dividend - sor, divisor, divisor, count, result); } }}; 字母异位词分组 NO.49题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]]说明： 所有输入均为小写字母。不考虑答案输出的顺序。 代码实现（参考用排序后的单词作为hashkey）： 执行结果 用量 排名 用时 112ms 超过23.14%用户 内存 16.4MB 超过–%用户 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { int sSize = strs.size(); vector&lt;vector&lt;string&gt;&gt; ret; map&lt;string, vector&lt;string&gt;&gt; store; map&lt;string, vector&lt;string&gt;&gt;::iterator iter; for(int i=0; i &lt; sSize; i++){ string toHash = strs[i]; sort(toHash.begin(), toHash.end()); store[toHash].push_back(strs[i]); } for(iter = store.begin(); iter != store.end(); iter++){ ret.push_back(iter-&gt;second); } return ret; }}; 代码实现（参考一次循环）： 执行结果 用量 排名 用时 56ms 超过98.19%用户 内存 14.8MB 超过100%用户 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { int sSize = strs.size(); vector&lt;vector&lt;string&gt;&gt; ret; unordered_map&lt;string, int&gt; store; for(int i=0; i &lt; sSize; i++){ string toHash = strs[i]; sort(toHash.begin(), toHash.end()); if(!store.count(toHash)){ store[toHash] = ret.size(); ret.push_back({}); } ret[store[toHash]].push_back(strs[i]); } return ret; }}; 螺旋矩阵 NO.54题目描述： 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 代码实现（原创， 按照运动轨迹移动指针，连续变向两次结束循环）： 执行结果 用量 排名 用时 4ms 超过37.74%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; ret; int row_num = matrix.size(); int col_num; if(row_num){ col_num = matrix[0].size(); } else{ return {}; } int circle = 0; int direct = 0; // 0:right 1:down 2:left 3:up int col = 0; int row = 0; int directCount = 0; while(directCount &lt; 2){ if(!directCount){ ret.push_back(matrix[row][col]); } switch(direct){ case 0:{ if(col != col_num - 1 - circle){ col++; directCount = 0; } else{ direct = 1; directCount++; } break; } case 1:{ if(row != row_num - 1 - circle){ row++; directCount = 0; } else{ direct = 2; directCount++; } break; } case 2:{ if(col != circle){ col--; directCount = 0; } else{ direct = 3; directCount++; } break; } case 3:{ if(row != circle + 1){ row--; directCount = 0; } else{ circle++; direct = 0; directCount++; } } } } return ret; }}; 代码实现（参考设置上下左右边界）： 执行结果 用量 排名 用时 4ms 超过37.74%用户 内存 6.7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; ret; int row_num = matrix.size(); int col_num; if(row_num){ col_num = matrix[0].size(); } else{ return {}; } int up = 0; int down = row_num - 1; int left = 0; int right = col_num - 1; while(1){ for(int i = left; i &lt;= right; i++){ ret.push_back(matrix[up][i]); } if(++up &gt; down) break; for(int i = up; i &lt;= down; i++){ ret.push_back(matrix[i][right]); } if(--right &lt; left) break; for(int i = right; i &gt;= left; i--){ ret.push_back(matrix[down][i]); } if(--down &lt; up) break; for(int i = down; i &gt;= up; i--){ ret.push_back(matrix[i][left]); } if(++left &gt; right) break; } return ret; }}; 最大子序和 NO.53题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 代码实现（参考动态规划）： 执行结果 用量 排名 用时 4ms 超过97.39%用户 内存 6.9MB 超过100%用户 123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int pre = 0; int MaxNum = nums[0]; for(int x : nums){ pre = max(pre + x, x); MaxNum = max(MaxNum, pre); } return MaxNum; }};","link":"/2020/07/20/LeetCode-Dairy-XII/"},{"title":"LeetCode Dairy XIII","text":"跳跃游戏 NO.55题目描述：给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置 代码实现（原创）： 执行结果 用量 排名 用时 40ms 超过6.31%用户 内存 13MB 超过8.70%用户 1234567891011121314151617181920212223class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); if(!nSize) return true; if(nSize == 1) return true; int arrive_pos = nSize - 1; for(int i = nSize - 2; i &gt;= 0;i--){ int distance = arrive_pos - i; if(nums[i] &gt;= distance){ arrive_pos = i; } } if(arrive_pos == 0){ return true; } else{ return false; } }}; 代码实现（参考贪心算法思想）： 执行结果 用量 排名 用时 28ms 超过19.63%用户 内存 12.8MB 超过8.70%用户 12345678910111213141516class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); int max_step = 0; for(int i = 0;i &lt; nSize; i++){ if(i &gt; max_step){ return false; } max_step = max(max_step , i + nums[i]); if(max_step &gt;= nSize - 1) return true; } return false; }}; 合并区间 NO.56题目描述：给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 代码实现（原创，排序后，暴力法）： 执行结果 用量 排名 用时 92ms 超过12.41%用户 内存 14.9MB 超过28.21%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; ret; int iSize = intervals.size(); if(!iSize) return {}; if(iSize == 1) return intervals; char map[iSize]; memset(map, 0, iSize); sort(intervals.begin(), intervals.end()); for(int i = 0; i &lt; iSize; i++){ if(map[i]) continue; vector&lt;int&gt; seed = intervals[i]; for(int j = i + 1; j &lt; iSize; j++){ if(map[j]) continue; vector&lt;int&gt; mergeResult = mergeTwo(seed, intervals[j]); if(mergeResult.size()){ map[j] = 1; seed = mergeResult; } } ret.push_back(seed); } return ret; } vector&lt;int&gt; mergeTwo(vector&lt;int&gt; a, vector&lt;int&gt; b){ vector&lt;int&gt; ret; int a_left = a[0]; int a_right = a[1]; int b_left = b[0]; int b_right = b[1]; if(a_left &gt;= b_left &amp;&amp; a_left &lt;= b_right){ int c_left = b_left; int c_right = max(b_right, a_right); ret.push_back(c_left); ret.push_back(c_right); return ret; } if(b_left &gt;= a_left &amp;&amp; b_left &lt;= a_right){ int c_left = a_left; int c_right = max(b_right, a_right); ret.push_back(c_left); ret.push_back(c_right); return ret; } return ret; } }; 代码实现（参考双指针方法）： 执行结果 用量 排名 用时 48ms 超过49.71%用户 内存 10.7MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; ret; sort(intervals.begin(), intervals.end()); int iSize = intervals.size(); if(!iSize) return {}; if(1 == iSize) return intervals; int start = intervals[0][0]; int end = intervals[0][1]; for(int i = 1; i &lt; iSize; i++){ int temp_start = intervals[i][0]; int temp_end = intervals[i][1]; if(end &gt;= temp_start){ if(end &lt; temp_end){ end = temp_end; } } else{ vector&lt;int&gt; temp; temp.push_back(start); temp.push_back(end); ret.push_back(temp); start = intervals[i][0]; end = intervals[i][1]; } if(i == iSize - 1){ vector&lt;int&gt; temp; temp.push_back(start); temp.push_back(end); ret.push_back(temp); } } return ret; }}; 最后一个单词的长度 NO.58题目描述：给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.7 MB 超过100%用户 1234567891011121314151617181920class Solution {public: int lengthOfLastWord(string s) { int sSize = s.size(); int count = 0; for(int i = sSize - 1; i &gt;= 0; i--){ if(s[i] == ' '){ if(count){ break; } else{ continue; } } count++; } return count; }}; 螺旋矩阵 II NO.59题目描述：给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 代码实现（参考上下左右边界缩减思想）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.9 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int up = 0; int down = n - 1; int left = 0; int right = n - 1; int cur = 1; while(1){ for(int i = left; i &lt;= right; i++){ matrix[up][i] = cur; cur++; } if(++up &gt; down) break; for(int i = up; i &lt;= down; i++){ matrix[i][right] = cur; cur++; } if(--right &lt; left) break; for(int i = right; i &gt;= left; i--){ matrix[down][i] = cur; cur++; } if(--down &lt; up) break; for(int i = down; i &gt;= up; i--){ matrix[i][left] = cur; cur++; } if(++left &gt; right) break; } return matrix; }}; 加一 NO.66题目描述：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 9 MB 超过5.88%用户 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int dSize = digits.size(); reverse(digits.begin(), digits.end()); int up = 1; for(int i = 0; i &lt; dSize; i++){ if(!up) break; int sum = up + digits[i]; digits[i] = sum % 10; up = sum / 10; } if(up){ digits.push_back(1); } reverse(digits.begin(), digits.end()); return digits; }};","link":"/2020/07/22/LeetCode-Dairy-XIII/"},{"title":"LeetCode Dairy XIV","text":"第k个排列 NO.60题目描述：给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123”“132”“213”“231”“312”“321”给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 代码实现（原创，根据序号，每次查找开头数字）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过100%用户 1234567891011121314151617181920212223242526class Solution {public: string getPermutation(int n, int k) { if(n == 0) return &quot;&quot;; string cur = &quot;&quot;; int factorialStore[n + 1]; int factorial = 1; vector&lt;int&gt; nums(n, 0); int toFind = k - 1; for(int i = 1; i &lt; n + 1; i++){ factorial *= i; factorialStore[i] = factorial; nums[i - 1] = i; } int count = 0; while(count != n){ int index = toFind / factorialStore[n - 1 - count]; toFind = toFind % factorialStore[n - 1 -count]; cur.push_back(nums[index] + '0'); nums.erase(nums.begin() + index); count++; } return cur; }}; 旋转链表 NO.61题目描述：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 代码实现（原创）： 执行结果 用量 排名 用时 8 ms 超过94.62%用户 内存 7.4 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* pre = new ListNode(1); pre-&gt;next = head; ListNode* front = pre; ListNode* behind = pre; int step = 0; int moved = 0; while(1){ if(k == 0) break; if(step &gt; 0 &amp;&amp; behind-&gt;next == NULL){ if(moved){ break; } else{ k = k % step; step = 0; front = pre; behind = pre; continue; } } behind = behind-&gt;next; if(step &gt;= k){ front = front-&gt;next; moved = 1; } step++; } ListNode *newHead = front-&gt;next; front-&gt;next = NULL; behind-&gt;next = head; delete(pre); return newHead; }}; 不同路径 NO.62题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 代码实现（原创，排列组合）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过100%用户 12345678910111213class Solution {public: int uniquePaths(int m, int n) { m--; n--; long long possible = 1; for(int i = 0; i &lt; n; i++){ possible = possible * (++m); possible = possible / (i+1); } return possible; }}; 代码实现（参考动态方程）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 5.9 MB 超过100%用户 12345678910111213141516class Solution {public: int uniquePaths(int m, int n) { int dp[m][n]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(i == 0 || j == 0){ dp[i][j] = 1; continue; } dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }}; 二进制求和 NO.67题目描述：给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100” 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6.5 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536class Solution {public: string addBinary(string a, string b) { int aSize = a.size(); int bSize = b.size(); int aIndex = aSize - 1; int bIndex = bSize - 1; string ret = &quot;&quot;; char up = 0; while(aIndex &gt;= 0 || bIndex &gt;= 0){ char n1 = 0; char n2 = 0; if(aIndex &gt;= 0){ n1 = a[aIndex] - '0'; aIndex--; } if(bIndex &gt;= 0){ n2 = b[bIndex] - '0'; bIndex--; } char sum = n1 + n2 + up; ret.push_back(sum % 2 + '0'); up = sum / 2; } if(up){ ret.push_back('1'); } reverse(ret.begin(), ret.end()); return ret; }};","link":"/2020/07/23/LeetCode-Dairy-XIV/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"hard","slug":"hard","link":"/tags/hard/"}],"categories":[{"name":"game","slug":"game","link":"/categories/game/"},{"name":"tech","slug":"tech","link":"/categories/tech/"}]}
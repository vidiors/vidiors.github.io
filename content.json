{"pages":[],"posts":[{"title":"DNF打造记录","text":"100级阿修罗装备附魔服务器: 跨六 价格日期: 2020年5月19日03:48:07 装备部位 附魔名称 附魔属性 获取方式 价格 头肩 天界支援兵 力50 智50 攻坚商店 反粒子35 上衣 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 下装 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 腰带 天界支援兵 力50 智50 攻坚商店 反粒子35 鞋 武器 孤独之拳凯芭朵娜 冰12 光12 拍卖 54w 手镯 维京首饰宝珠 光25 维京活动 维京硬币350 项链 维京首饰宝珠 光25 维京活动 维京硬币350 辅助装备 红腿爱克托 1级 物60 魔60 独60 拍卖 520w 戒指 维京首饰宝珠 光25 维京活动 维京硬币350 耳环 制造者卢克（光）上限 力智体精125 拍卖 1400w 魔法石 次元术士拉齐亚 上限 所有属强18 拍卖 310w 徽章镶嵌 装备部位 徽章颜色/个数 徽章属性 当前 目标 头肩 黄 2个 施放速度 1.6 1.6 上衣 绿 2个 智 魔爆 15 1.5 15 1.5 √ 下装 绿 2个 魔爆 2.2 15 1.5 15 1.5 腰带 红 2个 智 17 25 25 25 鞋 手镯 蓝2个 移速 1.1 1.1 项链 黄 2个 施放速度 1.6 1.6 辅助装备 白金 2个 无 意志白金 戒指 红 2个 智 17 17 25 25 魔法石 白金 2个 无 意志白金","link":"/2020/05/19/DNF%E6%89%93%E9%80%A0%E8%AE%B0%E5%BD%95/"},{"title":"Github Access Slow Solution","text":"win10系统： 编辑 C:\\Windows\\System32\\drivers\\etc\\hosts，添加内容： 12151.101.76.249 github.global-ssl.fastly.net 192.30.255.113 github.com","link":"/2020/04/11/Github-Access-Slow-Solution/"},{"title":"Linux Kernel Learning Dairy I","text":"1. GCC编译过程：预处理(pre-process): 预编译器(cpp)生成预编译后的源代码 -&gt; *.i 编译(compile): 编译器(ccl)生成汇编程序 -&gt; *.s 汇编(assemble): 汇编器(as)生成可重定位的目标程序 -&gt; *.o 链接(link): 链接器(ld)生成可执行二进制程序 -&gt; binary 2. Linux设备的三种类型a. 字符设备： 以字节为单位的 I/O 传输设备。如鼠标、键盘、触摸屏。 b. 块设备：以块为单位传输的设备。如磁盘。 c. 网络设备：网络协议相关设备。 3. 设备号主设备号（MAJOR）代表一类设备。 次设备号（MINOR）代表同一类设备的不同个体，每个次设备号都有一个不同的设备节点。","link":"/2020/06/14/Linux-Kernel-Learning-Dairy-I/"},{"title":"LeetCode Dairy I","text":"三数之和题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组 超时的解答：代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; vector&lt;int&gt; fine; sort(nums.begin(), nums.end()); map&lt;int, int&gt; restore_a; map&lt;int, int&gt;::iterator iter; int toFind; for(int i=0;i&lt;nums.size();i++){ iter = restore_a.find(nums[i]); if(iter != restore_a.end()){ continue; } restore_a[nums[i]] = 1; map&lt;int, int&gt; fmap; map&lt;int ,int&gt; restore_b; for(int j=i+1;j&lt;nums.size();j++){ toFind = (nums[i] + nums[j])* -1; iter = fmap.find(toFind); if(iter != fmap.end()){ iter = restore_b.find(nums[j]); if(iter != restore_b.end()){ continue; } restore_b[nums[j]] = 1; fine.clear(); fine.push_back(nums[i]); fine.push_back(nums[j]); fine.push_back(toFind); retSet.push_back(fine); } else{ fmap[nums[j]] = 1; } } } return retSet; }}; 参考双指针思路后的解答： 执行结果 用量 排名 用时 112ms 超过58.78% 内存 19.9MB 超过7.6% 代码实现（思路参考）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; if(nums.size() &lt; 3){ return retSet; } vector&lt;int&gt; bingo; sort(nums.begin(), nums.end()); int a_recent, b_recent, c_recent; for(int i=0;i&lt;nums.size()-2;i++){ if(nums[i]&gt;0){ break; } if(i&gt;0){ if(a_recent == nums[i]){ continue; } } a_recent = nums[i]; int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int sum = nums[i] + nums[j] + nums[k]; if(0 == sum){ bingo.clear(); bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); retSet.push_back(bingo); b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } if(sum &lt; 0){ b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } } if(sum &gt; 0){ c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } } } return retSet; }};","link":"/2020/07/04/LeetCode-Dairy-I/"},{"title":"LeetCode Dairy II","text":"1.最接近的三数之和题目描述：给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 通过解答： 执行结果 用量 排名 用时 16ms 超过65.7%用户 内存 10MB 超过7.14% 代码实现（原创）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { int ret; int min_distance; int first = 1; sort(nums.begin(), nums.end()); int len = nums.size(); int min = nums[0] + nums[1] + nums[2]; int max = nums[len - 1] + nums[len - 2] + nums[len - 3]; if(3 == nums.size()){ return min; } if(target &lt; min){ return min; } if(target &gt; max){ return max; } for(int i=0;i&lt;nums.size()-2;i++){ int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int distance = nums[i] + nums[j] + nums[k] - target; if(0 == distance){ return target; } if(first){ first = 0; min_distance = abs(distance); ret = target + distance; } if(abs(distance) &lt; min_distance){ min_distance = abs(distance); ret = target + distance; } if(distance &lt; 0){ j++; } if(distance &gt; 0){ k--; } } } return ret; }}; 电话号码的字母组合 NO. 17题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同） 通过解答： 执行结果 用量 排名 用时 0 ms 超过100% 内存 6.9 MB 超过100% 代码实现（原创）：123456789101112131415161718192021222324252627282930313233343536class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;vector&lt;string&gt;&gt; store = { {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, //2 {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;}, //3 {&quot;g&quot;, &quot;h&quot;, &quot;i&quot;}, //4 {&quot;j&quot;, &quot;k&quot;, &quot;l&quot;}, //5 {&quot;m&quot;, &quot;n&quot;, &quot;o&quot;}, //6 {&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;}, //7 {&quot;t&quot;, &quot;u&quot;, &quot;v&quot;}, //8 {&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;} //9 }; int len = digits.size(); vector&lt;string&gt; seed; if(!len){ return seed; } int index = 0; int numm = digits[index] - '0'; seed = store[numm - 2]; while(index &lt; len - 1){ vector&lt;string&gt; new_seed; for(int i = 0; i &lt; seed.size(); i++){ int num = digits[index + 1] - '0'; for(int j = 0; j &lt; store[num - 2].size(); j++){ string com = seed[i] + store[num - 2][j]; new_seed.push_back(com); } } seed = new_seed; index++; } return seed; }};","link":"/2020/07/05/LeetCode-Dairy-II/"},{"title":"斗鱼自动发弹幕js代码","text":"斗鱼循环发弹幕js代码：12345678910111213141516const area = document.getElementsByClassName('ChatSend-txt')[0]const btn = document.getElementsByClassName('ChatSend-button')[0]const danmu = '输入想发的弹幕内容'let intervalfunction start(){interval = setInterval(function(){area.value = danmubtn.click()},1000)}function stop(){clearInterval(interval)}start()","link":"/2020/06/06/%E6%96%97%E9%B1%BC%E8%87%AA%E5%8A%A8%E5%8F%91%E5%BC%B9%E5%B9%95js%E4%BB%A3%E7%A0%81/"},{"title":"LeetCode Dairy III","text":"四数之和 NO. 18题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 通过解答： 执行结果 用量 排名 用时 132ms 超过24.39%用户 内存 7.5MB 超过100% 代码实现（根据三数之和演变）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }}; 代码实现（参考边界判断思路的优化）： 执行结果 用量 排名 用时 16ms 超过90.03%用户 内存 7.4MB 超过100% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; if(nums[i] + nums[i + 1] * 3 &gt; target) break; //border if(nums[i] + nums[len - 1] * 3 &lt; target) continue; //border for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i] + nums[j] + nums[j + 1] * 2 &gt; target) break; //border if(nums[i] + nums[j] + nums[len - 1] * 2 &lt; target) continue; //border int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }};","link":"/2020/06/14/LeetCode-Dairy-III/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"game","slug":"game","link":"/categories/game/"},{"name":"tech","slug":"tech","link":"/categories/tech/"}]}
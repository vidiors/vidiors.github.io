{"pages":[],"posts":[{"title":"DNF打造记录","text":"100级阿修罗装备附魔服务器: 跨六 价格日期: 2020年5月19日03:48:07 装备部位 附魔名称 附魔属性 获取方式 价格 头肩 天界支援兵 力50 智50 攻坚商店 反粒子35 上衣 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 下装 触犯禁忌的白锈之希斯林 独50 智20 拍卖 170w 腰带 天界支援兵 力50 智50 攻坚商店 反粒子35 鞋 武器 孤独之拳凯芭朵娜 冰12 光12 拍卖 54w 手镯 维京首饰宝珠 光25 维京活动 维京硬币350 项链 维京首饰宝珠 光25 维京活动 维京硬币350 辅助装备 红腿爱克托 1级 物60 魔60 独60 拍卖 520w 戒指 维京首饰宝珠 光25 维京活动 维京硬币350 耳环 制造者卢克（光）上限 力智体精125 拍卖 1400w 魔法石 次元术士拉齐亚 上限 所有属强18 拍卖 310w 徽章镶嵌 装备部位 徽章颜色/个数 徽章属性 当前 目标 头肩 黄 2个 施放速度 1.6 1.6 上衣 绿 2个 智 魔爆 15 1.5 15 1.5 √ 下装 绿 2个 魔爆 2.2 15 1.5 15 1.5 腰带 红 2个 智 17 25 25 25 鞋 手镯 蓝2个 移速 1.1 1.1 项链 黄 2个 施放速度 1.6 1.6 辅助装备 白金 2个 无 意志白金 戒指 红 2个 智 17 17 25 25 魔法石 白金 2个 无 意志白金","link":"/2020/05/19/DNF%E6%89%93%E9%80%A0%E8%AE%B0%E5%BD%95/"},{"title":"Github Access Slow Solution","text":"win10系统： 编辑 C:\\Windows\\System32\\drivers\\etc\\hosts，添加内容： 12151.101.76.249 github.global-ssl.fastly.net 192.30.255.113 github.com","link":"/2020/04/11/Github-Access-Slow-Solution/"},{"title":"Linux Kernel Learning Dairy I","text":"1. GCC编译过程：预处理(pre-process): 预编译器(cpp)生成预编译后的源代码 -&gt; *.i 编译(compile): 编译器(ccl)生成汇编程序 -&gt; *.s 汇编(assemble): 汇编器(as)生成可重定位的目标程序 -&gt; *.o 链接(link): 链接器(ld)生成可执行二进制程序 -&gt; binary 2. Linux设备的三种类型a. 字符设备： 以字节为单位的 I/O 传输设备。如鼠标、键盘、触摸屏。 b. 块设备：以块为单位传输的设备。如磁盘。 c. 网络设备：网络协议相关设备。 3. 设备号主设备号（MAJOR）代表一类设备。 次设备号（MINOR）代表同一类设备的不同个体，每个次设备号都有一个不同的设备节点。","link":"/2020/06/14/Linux-Kernel-Learning-Dairy-I/"},{"title":"LeetCode Dairy I","text":"三数之和题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组 超时的解答：代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; vector&lt;int&gt; fine; sort(nums.begin(), nums.end()); map&lt;int, int&gt; restore_a; map&lt;int, int&gt;::iterator iter; int toFind; for(int i=0;i&lt;nums.size();i++){ iter = restore_a.find(nums[i]); if(iter != restore_a.end()){ continue; } restore_a[nums[i]] = 1; map&lt;int, int&gt; fmap; map&lt;int ,int&gt; restore_b; for(int j=i+1;j&lt;nums.size();j++){ toFind = (nums[i] + nums[j])* -1; iter = fmap.find(toFind); if(iter != fmap.end()){ iter = restore_b.find(nums[j]); if(iter != restore_b.end()){ continue; } restore_b[nums[j]] = 1; fine.clear(); fine.push_back(nums[i]); fine.push_back(nums[j]); fine.push_back(toFind); retSet.push_back(fine); } else{ fmap[nums[j]] = 1; } } } return retSet; }}; 参考双指针思路后的解答： 执行结果 用量 排名 用时 112ms 超过58.78% 内存 19.9MB 超过7.6% 代码实现（思路参考）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; retSet; if(nums.size() &lt; 3){ return retSet; } vector&lt;int&gt; bingo; sort(nums.begin(), nums.end()); int a_recent, b_recent, c_recent; for(int i=0;i&lt;nums.size()-2;i++){ if(nums[i]&gt;0){ break; } if(i&gt;0){ if(a_recent == nums[i]){ continue; } } a_recent = nums[i]; int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int sum = nums[i] + nums[j] + nums[k]; if(0 == sum){ bingo.clear(); bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); retSet.push_back(bingo); b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } if(sum &lt; 0){ b_recent = nums[j++]; while(j &lt; nums.size() &amp;&amp; b_recent == nums[j]){ j++; } } if(sum &gt; 0){ c_recent = nums[k--]; while(k &gt; 0 &amp;&amp; c_recent == nums[k] ){ k--; } } } } return retSet; }};","link":"/2020/07/04/LeetCode-Dairy-I/"},{"title":"LeetCode Dairy II","text":"1.最接近的三数之和题目描述：给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 通过解答： 执行结果 用量 排名 用时 16ms 超过65.7%用户 内存 10MB 超过7.14% 代码实现（原创）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { int ret; int min_distance; int first = 1; sort(nums.begin(), nums.end()); int len = nums.size(); int min = nums[0] + nums[1] + nums[2]; int max = nums[len - 1] + nums[len - 2] + nums[len - 3]; if(3 == nums.size()){ return min; } if(target &lt; min){ return min; } if(target &gt; max){ return max; } for(int i=0;i&lt;nums.size()-2;i++){ int j = i+1; int k = nums.size() - 1; while(j&lt;k){ int distance = nums[i] + nums[j] + nums[k] - target; if(0 == distance){ return target; } if(first){ first = 0; min_distance = abs(distance); ret = target + distance; } if(abs(distance) &lt; min_distance){ min_distance = abs(distance); ret = target + distance; } if(distance &lt; 0){ j++; } if(distance &gt; 0){ k--; } } } return ret; }}; 电话号码的字母组合 NO. 17题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同） 通过解答： 执行结果 用量 排名 用时 0 ms 超过100% 内存 6.9 MB 超过100% 代码实现（原创）：123456789101112131415161718192021222324252627282930313233343536class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;vector&lt;string&gt;&gt; store = { {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, //2 {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;}, //3 {&quot;g&quot;, &quot;h&quot;, &quot;i&quot;}, //4 {&quot;j&quot;, &quot;k&quot;, &quot;l&quot;}, //5 {&quot;m&quot;, &quot;n&quot;, &quot;o&quot;}, //6 {&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;}, //7 {&quot;t&quot;, &quot;u&quot;, &quot;v&quot;}, //8 {&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;} //9 }; int len = digits.size(); vector&lt;string&gt; seed; if(!len){ return seed; } int index = 0; int numm = digits[index] - '0'; seed = store[numm - 2]; while(index &lt; len - 1){ vector&lt;string&gt; new_seed; for(int i = 0; i &lt; seed.size(); i++){ int num = digits[index + 1] - '0'; for(int j = 0; j &lt; store[num - 2].size(); j++){ string com = seed[i] + store[num - 2][j]; new_seed.push_back(com); } } seed = new_seed; index++; } return seed; }};","link":"/2020/07/05/LeetCode-Dairy-II/"},{"title":"斗鱼自动发弹幕js代码","text":"斗鱼循环发弹幕js代码：12345678910111213141516const area = document.getElementsByClassName('ChatSend-txt')[0]const btn = document.getElementsByClassName('ChatSend-button')[0]const danmu = '输入想发的弹幕内容'let intervalfunction start(){interval = setInterval(function(){area.value = danmubtn.click()},1000)}function stop(){clearInterval(interval)}start()","link":"/2020/06/06/%E6%96%97%E9%B1%BC%E8%87%AA%E5%8A%A8%E5%8F%91%E5%BC%B9%E5%B9%95js%E4%BB%A3%E7%A0%81/"},{"title":"LeetCode Dairy III","text":"四数之和 NO. 18题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 通过解答： 执行结果 用量 排名 用时 132ms 超过24.39%用户 内存 7.5MB 超过100% 代码实现（根据三数之和演变）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }}; 代码实现（参考边界判断思路的优化）： 执行结果 用量 排名 用时 16ms 超过90.03%用户 内存 7.4MB 超过100% 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; retSet; int len = nums.size(); if(len &lt; 4){ return retSet; } sort(nums.begin(), nums.end()); for(int i = 0;i &lt; len - 3;i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; if(nums[i] + nums[i + 1] * 3 &gt; target) break; //border if(nums[i] + nums[len - 1] * 3 &lt; target) continue; //border for(int j = i + 1;j &lt; len -2; j++){ if( j &gt; i + 1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i] + nums[j] + nums[j + 1] * 2 &gt; target) break; //border if(nums[i] + nums[j] + nums[len - 1] * 2 &lt; target) continue; //border int k = j + 1; int l = len - 1; while(k &lt; l){ int distance = nums[i] + nums[j] + nums[k] + nums[l] - target; if(distance == 0){ vector&lt;int&gt; bingo; bingo.push_back(nums[i]); bingo.push_back(nums[j]); bingo.push_back(nums[k]); bingo.push_back(nums[l]); retSet.push_back(bingo); while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &gt; 0){ while(l &gt; 1 &amp;&amp; nums[l] &amp;&amp; nums[l] == nums[l - 1]) l--; l--; } if(distance &lt; 0){ while(k &lt; len - 1 &amp;&amp; nums[k] == nums[k + 1]) k++; k++; } } } } return retSet; }};","link":"/2020/07/06/LeetCode-Dairy-III/"},{"title":"LeetCode Dairy IV","text":"删除链表的倒数第N个节点 NO.19题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 代码实现（原创，使用了哈希表）： 执行结果 用量 排名 用时 8ms 超过52.60%用户 内存 7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(n == 0){ return head; } map&lt;int, ListNode*&gt; store; map&lt;int, ListNode*&gt;::iterator iter; ListNode *cur = head; ListNode *ret = head; int index = 0; while(cur-&gt;next){ store[index] = cur; cur = cur-&gt;next; index++; } int len = index + 1; if(n &gt; len){ return NULL; } if(n == len){ //to free ret = head-&gt;next; delete(head); return ret; } int index_fo_find = len - n - 1; iter = store.find(index_fo_find); if(iter != store.end()){ ListNode* found = iter-&gt;second; ListNode* toFree = found-&gt;next; found-&gt;next = found-&gt;next-&gt;next; delete(toFree); } return ret; }}; 参考高速答案（双指针间隔n同步移动，实现如下）： 执行结果 用量 排名 用时 4ms 超过93.94%用户 内存 6.4MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(0 == n){ return head; } ListNode* pre = new ListNode(1); pre-&gt;next = head; ListNode* ptrA = pre; ListNode* ptrB = pre; int index = 0; int flag = 0; while(ptrB-&gt;next){ ptrB = ptrB-&gt;next; if(index == n){ flag = 1; } if(flag){ ptrA = ptrA-&gt;next; } index++; } if(!flag){ ListNode* ret = head; ListNode* toFree = head; ret = head-&gt;next; delete(toFree); delete(pre); return ret; } ListNode* toFree = ptrA-&gt;next; ptrA-&gt;next = ptrA-&gt;next-&gt;next; delete(toFree); delete(pre); return head; }}; 有效的括号 NO.20给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 代码实现（原创，栈）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.5MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: bool isValid(string s) { stack&lt;char&gt; stack; for(int i = 0;i &lt; s.size(); i++){ switch(s[i]){ case '(': case '{': case '[': { stack.push(s[i]); break; } case ')':{ if(!stack.empty() &amp;&amp; stack.top() == '('){ stack.pop(); } else{ return false; } break; } case '}':{ if(!stack.empty() &amp;&amp; stack.top() == '{'){ stack.pop(); } else{ return false; } break; } case ']':{ if(!stack.empty() &amp;&amp; stack.top() == '['){ stack.pop(); } else{ return false; } break; } default: return false; } } if(stack.empty()){ return true; } return false; }}; 合并两个有序链表 NO.21题目描述：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 代码实现（原创） 执行结果 用量 排名 用时 12ms 超过57.74%用户 内存 14.4MB 超过5.61%用户 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(); ListNode* head = l3; while(l1 &amp;&amp; l2){ if(l1-&gt;val &lt;= l2-&gt;val){ l3-&gt;next = l1; l3 = l3-&gt;next; l1 = l1-&gt;next; } else{ l3-&gt;next = l2; l3 = l3-&gt;next; l2 = l2-&gt;next; } } if(l1){ l3-&gt;next = l1; } if(l2){ l3-&gt;next = l2; } return head-&gt;next; }}; 代码实现（参考递归思想） 执行结果 用量 排名 用时 4ms 超过99.17%用户 内存 14.4MB 超过5.61%用户 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1){ return l2; } if(!l2){ return l1; } if(l1-&gt;val &lt;= l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else{ l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }};","link":"/2020/07/08/LeetCode-Dairy-IV/"},{"title":"LeetCode Dairy V","text":"括号生成 NO.22题目描述：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 代码实现（参考深度优先遍历答案）： 执行结果 用量 排名 用时 4ms 超过89.85%用户 内存 15.1MB 超过–%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; ret; string cur=&quot;&quot;; generate(cur, n, n, ret); return ret; } void generate(string current, int left, int right, vector&lt;string&gt; &amp;result){ if(left == 0 &amp;&amp; right == 0){ result.push_back(current); return; } if(left &gt; right){ return; } if(left &gt; 0){ generate(current + &quot;(&quot;, left - 1, right,result); } if(right &gt; 0){ generate(current + &quot;)&quot;, left, right - 1,result); } }}; 代码实现（参考动态规划思想）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 8.1MB 超过100%用户 1234567891011121314151617181920212223class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;vector&lt;string&gt;&gt; allset; allset.push_back({&quot;&quot;}); //for n = 0 allset.push_back({&quot;()&quot;}); //for n = 1 for(int i = 2; i &lt;= n; i++){ vector&lt;string&gt; newSet; for(int j = 0; j &lt; i; j++){ vector&lt;string&gt; setIn = allset[j]; vector&lt;string&gt; setOut = allset[i-1-j]; for(int k = 0; k &lt; setIn.size(); k++){ for(int l = 0; l &lt; setOut.size(); l++){ string newCombine = &quot;(&quot; + setIn[k] + &quot;)&quot; + setOut[l]; newSet.push_back(newCombine); } } } allset.push_back(newSet); } return allset[n]; }}; 删除排序数组中的重复项 NO.26题目描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 代码实现（原创，把不同的值直接按顺序覆盖数组的值） 执行结果 用量 排名 用时 8ms 超过99.99%用户 内存 7.5MB 超过100%用户 1234567891011121314151617181920class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int lastNum; int cur = 0; for(int i=0; i &lt; nums.size(); i++){ if(i &gt; 0){ if(nums[i] == lastNum){ continue; } nums[cur++] = nums[i]; } else{ cur++; } lastNum = nums[i]; } return cur; }};","link":"/2020/07/10/LeetCode-Dairy-V/"},{"title":"LeetCode Dairy VI","text":"移除元素 NO.27题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.2MB 超过100%用户 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int cur = 0; for(int i = 0;i &lt; nums.size(); i++){ if(nums[i] != val){ nums[cur++] = nums[i]; } } return cur; }}; 实现 strStr() NO.28题目描述：给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 代码实现（原创， 暴力解法）： 执行结果 用量 排名 用时 4ms 超过79.02%用户 内存 6.9MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int strStr(string haystack, string needle) { if(needle == &quot;&quot;){ return 0; } int pos = -1; int h_size = haystack.size(); int n_size = needle.size(); bool flag = 0; int needle_index = 0; for(int i = 0; i &lt; h_size;){ if(!flag &amp;&amp; haystack[i] == needle[needle_index]){ if(i + n_size &gt; h_size){ return -1; } flag = 1; pos = i; needle_index++; if(needle_index == n_size){ return pos; } i++; continue; } if(flag){ if(haystack[i] == needle[needle_index]){ needle_index++; i++; if(needle_index == n_size){ return pos; } continue; } else{ i = pos + 1; flag = 0; pos = -1; needle_index = 0; continue; } } i++; } return pos; }}; 代码实现（参考KMP算法实现，效率不理想）：思路总结： 构造dp数组，其中x记录的是当前状态包含的前缀，使用了类似双指针的方式构造，x在i指针左侧，与i指针共享判断字符j，当前j不满足x前进条件，则x会回退到0。 执行结果 用量 排名 用时 64ms 超过5.18%用户 内存 43.2MB 超过5.77%用户 1234567891011121314151617181920212223242526272829303132class Solution {public: int strStr(string haystack, string needle) { int nSize = needle.size(); int hSize = haystack.size(); int state = 0; if(!nSize){ return 0; } int dp[nSize][256]; memset(dp, 0, nSize*256); dp[0][needle[0]] = 1; int x = 0; for(int i = 1; i &lt; nSize; i++){ for(int j = 0; j &lt; 256; j++){ dp[i][j] = dp[x][j]; dp[i][needle[i]] = i + 1; } x = dp[x][needle[i]]; } for(int k = 0; k &lt; hSize; k++){ state = dp[state][haystack[k]]; if(state == nSize){ return k - nSize + 1; } } return -1; }}; 代码实现（参考SUNDAY算法思想，效率与暴力法相差无几）： 执行结果 用量 排名 用时 4ms 超过78.9%用户 内存 7.2MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334class Solution {public: int strStr(string haystack, string needle) { int hSize = haystack.size(); int nSize = needle.size(); if(!nSize){ return 0; } map&lt;char, int&gt; offsetMap; map&lt;char, int&gt;::iterator iter; for(int i =0 ;i &lt; nSize; i++){ offsetMap[needle[i]] = nSize - i; } for(int j=0; j&lt; hSize;){ if(j + nSize &gt; hSize){ return -1; } if(haystack.substr(j, nSize) == needle){ return j; } int tofind = j + nSize; iter = offsetMap.find(haystack[tofind]); if(iter != offsetMap.end()){ j += offsetMap[haystack[tofind]]; } else{ j += nSize + 1; } } return -1; }};","link":"/2020/07/11/LeetCode-Dairy-VI/"},{"title":"Algorithm Ideas","text":"算法解题思路：排序 哈希 双指针 值逼迫 边界判定 递归 深度优先遍历 动态规划 KMP","link":"/2020/07/11/Algorithm-Ideas/"},{"title":"LeetCode Dairy VII","text":"搜索插入位置 NO.35题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 代码实现（原创, 类似二分法）： 执行结果 用量 排名 用时 4ms 超过95.84%用户 内存 6.6MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize){ return 0; } int start = 0; int end = nSize - 1; if(target &lt;= nums[start]){ return 0; } if(target &gt; nums[end]){ return nSize; } int mid = (start + end)/2; while(end - start &gt; 1){ if(nums[mid] == target){ return mid; } if(nums[mid] &gt; target){ end = mid; } if(nums[mid] &lt; target){ start = mid; } mid = (start + end)/2; } return mid + 1; }}; 规范二分查找实现： 12345678910111213141516171819202122232425class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize){ return 0; } int start = 0; int end = nSize - 1; int mid = (start + end)/2; while(start &lt;= end){ if(nums[mid] == target){ return mid; } if(nums[mid] &gt; target){ end = mid - 1; } if(nums[mid] &lt; target){ start = mid + 1; } mid = (start + end)/2; } return start; }}; 外观数列 NO.38题目描述：给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。 注意：整数序列中的每一项将表示为一个字符串。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下： 1 11 21 1211 111221第一项是数字 1 描述前一项，这个数是 1 即 “一个 1 ”，记作 11 描述前一项，这个数是 11 即 “两个 1 ” ，记作 21 描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211 描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221 代码实现（原创, 非递归）： 执行结果 用量 排名 用时 4ms 超过84.94%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829class Solution {public: string countAndSay(int n) { string cur = &quot;1&quot;; for(int i = 2; i &lt; n + 1; i++){ string temp = &quot;&quot;; int index = 1; int cSize = cur.size(); char lastC = cur[0]; int count = 1; while(index &lt; cSize){ if(cur[index] == lastC){ count++; } else{ temp += to_string(count); temp.push_back(lastC); count = 1; } lastC = cur[index]; index++; } temp += to_string(count); temp.push_back(lastC); cur = temp; } return cur; }}; 代码实现（原创，递归）： 执行结果 用量 排名 用时 4ms 超过84.94%用户 内存 6.8MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: string countAndSay(int n) { if(n == 1){ return &quot;1&quot;; } string cur = countAndSay(n - 1); string temp = &quot;&quot;; int index = 1; int cSize = cur.size(); char lastC = cur[0]; int count = 1; while(index &lt; cSize){ if(cur[index] == lastC){ count++; } else{ temp += to_string(count); temp.push_back(lastC); count = 1; } lastC = cur[index]; index++; } temp += to_string(count); temp.push_back(lastC); cur = temp; return cur; }}; 两两交换链表中的节点 NO.24题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过65.97%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode *pre = new ListNode(1); pre-&gt;next = head; ListNode *newHead = pre; ListNode *cur = head; while(cur &amp;&amp; cur-&gt;next){ ListNode *afterNext = cur-&gt;next-&gt;next; pre-&gt;next = cur-&gt;next; cur-&gt;next = afterNext; pre-&gt;next-&gt;next = cur; pre = cur; cur = afterNext; } return newHead-&gt;next; }}; 代码实现（原创，递归） 执行结果 用量 排名 用时 4ms 超过65.97%用户 内存 6.5MB 超过100%用户 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { if(!head){ return NULL; } if(!head-&gt;next){ return head; } ListNode *nextHead = head-&gt;next-&gt;next; ListNode *temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; temp-&gt;next = head; head = temp; if(nextHead){ head-&gt;next-&gt;next = swapPairs(nextHead); } return head; }};","link":"/2020/07/13/LeetCode-Dairy-VII/"},{"title":"LeetCode Dairy VIII","text":"下一个排列 NO.31题目描述：实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过88.50%用户 内存 12.3MB 超过6.67%用户 1234567891011121314151617181920212223class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); for(int i = nSize - 1; i &gt;= 0 ; i--){ if(i - 1 &gt;=0 &amp;&amp; nums[i] &gt; nums[i-1]){ int toChange = i; for(int j = nSize - 1; j &gt;= i; j--){ if(nums[j] &gt; nums[i-1]){ toChange = j; break; } } int tmp = nums[i-1]; nums[i-1] = nums[toChange]; nums[toChange] = tmp; reverse(nums.begin() + i , nums.end()); return; } } sort(nums.begin(), nums.end()); }}; 搜索旋转排序数组 NO.33题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize) return -1; int start = 0; int end = nSize - 1; int mid = start + (end - start)/2; while(start &lt;= end){ if(nums[mid] == target){ return mid; } if(target &lt;= nums[end]){ if(nums[mid] &lt;= nums[end]){ if(target &lt; nums[mid]){ end = mid - 1; } else{ start = mid + 1; } } else{ start = mid + 1; } } else if(target &gt;= nums[start]){ if(nums[mid] &gt;= nums[start]){ if(target &lt; nums[mid]){ end = mid - 1; } else{ start = mid + 1; } } else{ end = mid - 1; } } else{ return -1; } mid = start + (end - start)/2; } return -1; }}; 在排序数组中查找元素的第一个和最后一个位置 NO.34题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 代码实现（原创）： 执行结果 用量 排名 用时 24ms 超过9.62%用户 内存 13.7MB 超过6.52%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ret; int nSize = nums.size(); int start = 0; int end = nSize - 1; int mid = start + (end - start)/2; int left = -1; int right = -1; int count = 0; int start_right = 0; int end_right = nSize - 1; while(start &lt;= end){ if(target == nums[mid]){ left = mid; end = mid - 1; } if(target &lt; nums[mid]){ end = mid - 1; } if(target &gt; nums[mid]){ start = mid + 1; } mid = start + (end - start)/2; } start = 0; end = nSize - 1; mid = start + (end - start)/2; while(start &lt;= end){ if(target == nums[mid]){ right = mid; start = mid + 1; } if(target &lt; nums[mid]){ end = mid - 1; } if(target &gt; nums[mid]){ start = mid + 1; } mid = start + (end - start)/2; } ret.push_back(left); ret.push_back(right); return ret; }};","link":"/2020/07/14/LeetCode-Dairy-VIII/"},{"title":"LeetCode Dairy IX","text":"有效的数独 NO.36题目描述：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 代码实现（原创, 暴力法）： 执行结果 用量 排名 用时 28ms 超过22.76%用户 内存 8.7MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { //row detect for(int i = 0; i &lt; 9; i++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int j = 0; j &lt; 9; j++){ if('.' == board[i][j]) continue; iter = detectMap.find(board[i][j]); if(iter != detectMap.end()){ return false; } detectMap[board[i][j]] = 1; } } //column detect for(int i = 0; i &lt; 9; i++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int j = 0; j &lt; 9; j++){ if('.' == board[j][i]) continue; iter = detectMap.find(board[j][i]); if(iter != detectMap.end()){ return false; } detectMap[board[j][i]] = 1; } } //3*3 detect for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ map&lt;char, int&gt; detectMap; map&lt;char, int&gt;::iterator iter; for(int l = 0; l &lt; 3; l++){ for(int k=0; k &lt; 3; k++){ int x = 3*i + l; int y = 3*j + k; if('.' == board[x][y]) continue; iter = detectMap.find(board[x][y]); if(iter != detectMap.end()){ return false; } detectMap[board[x][y]] = 1; } } } } return true; }}; 代码实现（参考优化思路） 执行结果 用量 排名 用时 16ms 超过71.37%用户 内存 7.2MB 超过100%用户 123456789101112131415161718192021222324252627class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { int row[9][10] = {{0}}; int col[9][10] = {{0}}; int block[9][10] = {{0}}; for(int i = 0; i &lt; 9; i++){ for(int j = 0; j &lt; 9; j++){ int value = board[i][j]; if('.' == value) continue; value = value - '0'; if(row[i][value]) return false; row[i][value] = 1; if(col[j][value]) return false; col[j][value] = 1; int blockIndex = i/3 * 3 + j/3; if(block[blockIndex][value]) return false; block[blockIndex][value] = 1; } } return true; }}; 组合总和 NO.39题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 代码实现（参考深度优先遍历）： 执行结果 用量 排名 用时 40ms 超过21.36%用户 内存 14.2MB 超过18.64%用户 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; sort(candidates.begin(), candidates.end()); int index = 0; toFind(cur, candidates, target, ret, index); return ret; } void toFind(vector&lt;int&gt; current, vector&lt;int&gt; &amp;candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result, int left){ vector&lt;int&gt;::iterator iter; int index = left; for(iter = candidates.begin() + left; iter != candidates.end(); iter++){ if(*iter == target){ current.push_back(target); result.push_back(current); return; } if(*iter &lt; target){ vector&lt;int&gt; temp = current; temp.push_back(*iter); toFind(temp, candidates, target - *iter, result, index); } index++; } }}; 代码实现（细节优化，使用引用，减少拷贝） 执行结果 用量 排名 用时 8ms 超过83.29%用户 内存 10.8MB 超过33.90%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int index = 0; toFind(cur, candidates, target, ret, index); return ret; } void toFind(vector&lt;int&gt; &amp;current, vector&lt;int&gt; &amp;candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result, int left){ if(target == 0){ result.push_back(current); return; } if(target &lt; 0){ return; } for(int i = left; i &lt; candidates.size(); i++){ current.push_back(candidates[i]); toFind(current, candidates, target - candidates[i], result, i); current.pop_back(); } }};","link":"/2020/07/15/LeetCode-Dairy-IX/"},{"title":"LeetCode Dairy X","text":"组合总和 II NO.40题目描述：给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 代码实现（原创）： 执行结果 用量 排名 用时 8ms 超过78.29%用户 内存 7.1MB 超过100%用户 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; sort(candidates.begin(), candidates.end()); toFind(cur, candidates, target, ret,0); return ret; } void toFind(vector&lt;int&gt; &amp;current, vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt; &amp;result,int left){ if(target == 0){ result.push_back(current); return; } if(target &lt; 0) return; int count = 0; for(int i = left; i &lt; candidates.size(); i++){ if(count &amp;&amp; candidates[i] == candidates[i - 1]){ continue; } current.push_back(candidates[i]); toFind(current, candidates, target - candidates[i], result, i + 1); current.pop_back(); count++; } }}; 全排列 NO.46题目描述：给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 代码实现（原创）： 执行结果 用量 排名 用时 4ms 超过88.91%用户 内存 7.4MB 超过100%用户 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int fg[nums.size()]; memset(fg, 0, nums.size() * sizeof(int)); toFind(cur, nums, ret, fg); return ret; } void toFind(vector&lt;int&gt;&amp; current, vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, int *flag){ if(current.size() == nums.size()){ result.push_back(current); return; } for(int i = 0; i&lt;nums.size(); i++){ if(flag[i]){ continue; } current.push_back(nums[i]); flag[i] = 1; toFind(current, nums, result, flag); current.pop_back(); flag[i] = 0; } }}; 全排列 II NO.47题目描述：给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 代码实现（原创，多次递归不选相同下标，同一次递归内不选取相同值的元素）： 执行结果 用量 排名 用时 4ms 超过99.25%用户 内存 7.7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; int nSize = nums.size(); char fg[nSize]; memset(fg, 0, nSize); sort(nums.begin(), nums.end()); toFind(cur, nums, ret, fg); return ret; } void toFind(vector&lt;int&gt;&amp; current, vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, char* flag){ if(current.size() == nums.size()){ result.push_back(current); return; } int count = 0; int lastIn; for(int i = 0; i &lt; nums.size(); i++){ if(flag[i]) continue; if(count &amp;&amp; nums[i] == lastIn) continue; lastIn = nums[i]; current.push_back(nums[i]); flag[i] = 1; toFind(current, nums, result, flag); current.pop_back(); flag[i] = 0; count++; } }}; 字符串相乘 NO.43题目描述：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = “2”, num2 = “3”输出: “6”示例 2: 输入: num1 = “123”, num2 = “456”输出: “56088”说明： num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 代码实现（原创，暴力法）： 执行结果 用量 排名 用时 64ms 超过16.21%用户 内存 11.5MB 超过25.93%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution {public: string multiply(string num1, string num2) { int nSize1 = num1.size(); int nSize2 = num2.size(); if(!nSize1 || !nSize1) return &quot;&quot;; if(nSize1 == 1 &amp;&amp; num1 == &quot;0&quot;){ return &quot;0&quot;; } if(nSize2 == 1 &amp;&amp; num2 == &quot;0&quot;){ return &quot;0&quot;; } string seed = &quot;&quot;; for(int i = nSize1 - 1; i &gt;=0; i--){ char multiSeed = 0; string temp = &quot;&quot;; for(int j = nSize2 - 1; j &gt;= 0; j--){ char multi = (num1[i] - '0') * (num2[j] - '0') + multiSeed; multiSeed = multi / 10; temp.push_back(multi % 10 + '0'); } if(multiSeed){ temp.push_back(multiSeed + '0'); } reverse(temp.begin(), temp.end()); for(int k = 0; k &lt; nSize1 - 1 - i; k++){ temp.push_back('0'); } seed = sum(seed, temp); } return seed; } string sum(string n1, string n2){ int index1 = n1.size() - 1; int index2 = n2.size() - 1; int up = 0; string store = &quot;&quot;; while(index1 &gt;=0 || index2 &gt;= 0){ char p1, p2; if(index1 &gt;=0){ p1 = n1[index1] - '0'; index1--; } else{ p1 = 0; } if(index2 &gt;= 0){ p2 = n2[index2] - '0'; index2--; } else{ p2 = 0; } char s = p1 + p2 + up; if(s &gt;= 10){ s -= 10; up = 1; } else{ up = 0; } store.push_back(s + '0'); } if(up){ store.push_back('1'); } reverse(store.begin(), store.end()); return store; }}; 代码实现（参考优化竖式思路）两个数，N1长度为n，N2长度为m，相乘之后，最大总位数为m+n 执行结果 用量 排名 用时 4ms 超过98.89%用户 内存 6.5MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536class Solution {public: string multiply(string num1, string num2) { int size1 = num1.size(); int size2 = num2.size(); if(size1 == 1 &amp;&amp; num1 == &quot;0&quot;){ return &quot;0&quot;; } if(size2 == 1 &amp;&amp; num2 == &quot;0&quot;){ return &quot;0&quot;; } reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); string result = &quot;&quot;; vector&lt;char&gt; store(size1 + size2, 0); char up = 0; for(int i = 0;i &lt; size1; i++){ for(int j = 0;j &lt; size2; j++){ char multi = (num1[i] - '0') * (num2[j] - '0') + store[i + j]; char one = multi % 10; char ten = multi / 10; store[i+j] = one; store[i+j+1] += ten; } } int flag = 1; for(int k = size1 + size2 - 1; k &gt;= 0; k--){ if(flag &amp;&amp; store[k] == 0){ continue; } flag = 0; result.push_back(store[k] + '0'); } return result; }};","link":"/2020/07/16/LeetCode-Dairy-X/"},{"title":"LeetCode Dairy XI","text":"旋转图像 NO.48题目描述：给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix =[ [1,2,3], [4,5,6], [7,8,9]], 原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 代码实现（原创，先逆置，再调转）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.2MB 超过100%用户 123456789101112131415161718class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0;i &lt; n; i++){ for(int j = 0;j &lt; n;j++){ if(i &lt; j){ int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } } for(int k = 0; k &lt; n; k++){ reverse(matrix[k].begin(), matrix[k].end()); } }}; 代码实现（参考以四个点为单位旋转，寻找四个点关系的思想）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.3MB 超过100%用户 123456789101112131415class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0; i &lt; n/2; i++){ for(int j = i; j &lt; n- 1 -i; j++){ int temp = matrix[i][j]; matrix[i][j] = matrix[n - 1 - j][i]; matrix[n - 1 -j ][i] = matrix[n - 1 -i][n - 1 -j]; matrix[n - 1 -i][n - 1 -j] = matrix[j][n-1-i]; matrix[j][n-1-i] = temp; } } }}; 代码实现（参考运动轨迹思想）： 执行结果 用量 排名 用时 4 ms 超过61.25%用户 内存 7.2MB 超过100%用户 123456789101112131415161718192021222324class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); int stepSub = n - 1; int stepPlus = 0; while(stepSub &gt;= stepPlus){ int start = stepPlus; int end = stepSub; while(start != stepSub){ int temp = matrix[stepPlus][start]; matrix[stepPlus][start] = matrix[end][stepPlus]; matrix[end][stepPlus] = matrix[stepSub][end]; matrix[stepSub][end] = matrix[start][stepSub]; matrix[start][stepSub] = temp; end--; start++; } stepSub--; stepPlus++; } }};","link":"/2020/07/17/LeetCode-Dairy-XI/"},{"title":"LeetCode Dairy XII","text":"两数相除 NO.29题目描述：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。 代码实现（原创，将被除数和除数都转换成负数，防止越界，c++ 负数不能左移，先转换成无符号整型）： 执行结果 用量 排名 用时 4ms 超过60.71%用户 内存 5.8MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution {public: int divide(int dividend, int divisor) { int sign = 1; int ret = 0; if(divisor &lt; 0){ sign = 0 - sign; } else{ divisor = 0 - divisor; } if(dividend &lt; 0){ sign = 0 - sign; } else{ dividend = 0 - dividend; } int end = dividend; int seed = divisor; int count = 0; int overflow = 0; while( seed &gt;= end){ while(seed &gt;= end){ if(seed &lt;= INT_MIN&gt;&gt;1){ if(!count){ overflow = 1; count++; } break; } seed = (unsigned int)seed&lt;&lt;1; count++; } if(count) { ret -= 1&lt;&lt;(count - 1); } int last_value; if(!overflow){ last_value = seed&gt;&gt;1; } else{ last_value = seed; } end = end - last_value; seed = divisor; count = 0; } if(sign &lt; 0){ return ret; } else{ if(ret == INT_MIN){ return INT_MAX; } return 0 - ret; } }}; 代码实现（参考不用位操作的递归思想） 执行结果 用量 排名 用时 0ms 超过100%用户 内存 5.9MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution {public: int divide(int dividend, int divisor) { int ret = 0; int count = 0; int sign = 1; if(dividend &lt; 0){ sign = 0 - sign; } else{ dividend = 0 - dividend; } if(divisor &lt; 0){ sign = 0 - sign; } else{ divisor = 0 - divisor; } div(dividend, divisor, divisor, count, ret); if(sign &gt; 0){ if(ret == INT_MIN){ return INT_MAX; } else{ return 0 - ret; } } return ret; } void div(int dividend, int divisor, int sor, int count,int &amp;result){ if(dividend &gt; divisor){ return; } if(dividend == divisor){ result--; return; } int toClose; int overflow = 0; if(sor &lt; INT_MIN&gt;&gt;1){ overflow = 1; toClose = sor; } else{ toClose = sor + sor; } if(!overflow &amp;&amp; toClose &gt; dividend){ if(!count) { count = 1; } count = count + count; div(dividend, divisor, toClose, count, result); } if(overflow || toClose &lt;= dividend){ if(!count){ result -= 1; } else{ result -= count; } count = 0; div(dividend - sor, divisor, divisor, count, result); } }}; 字母异位词分组 NO.49题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]]说明： 所有输入均为小写字母。不考虑答案输出的顺序。 代码实现（参考用排序后的单词作为hashkey）： 执行结果 用量 排名 用时 112ms 超过23.14%用户 内存 16.4MB 超过–%用户 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { int sSize = strs.size(); vector&lt;vector&lt;string&gt;&gt; ret; map&lt;string, vector&lt;string&gt;&gt; store; map&lt;string, vector&lt;string&gt;&gt;::iterator iter; for(int i=0; i &lt; sSize; i++){ string toHash = strs[i]; sort(toHash.begin(), toHash.end()); store[toHash].push_back(strs[i]); } for(iter = store.begin(); iter != store.end(); iter++){ ret.push_back(iter-&gt;second); } return ret; }}; 代码实现（参考一次循环）： 执行结果 用量 排名 用时 56ms 超过98.19%用户 内存 14.8MB 超过100%用户 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { int sSize = strs.size(); vector&lt;vector&lt;string&gt;&gt; ret; unordered_map&lt;string, int&gt; store; for(int i=0; i &lt; sSize; i++){ string toHash = strs[i]; sort(toHash.begin(), toHash.end()); if(!store.count(toHash)){ store[toHash] = ret.size(); ret.push_back({}); } ret[store[toHash]].push_back(strs[i]); } return ret; }}; 螺旋矩阵 NO.54题目描述： 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 代码实现（原创， 按照运动轨迹移动指针，连续变向两次结束循环）： 执行结果 用量 排名 用时 4ms 超过37.74%用户 内存 6.5MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; ret; int row_num = matrix.size(); int col_num; if(row_num){ col_num = matrix[0].size(); } else{ return {}; } int circle = 0; int direct = 0; // 0:right 1:down 2:left 3:up int col = 0; int row = 0; int directCount = 0; while(directCount &lt; 2){ if(!directCount){ ret.push_back(matrix[row][col]); } switch(direct){ case 0:{ if(col != col_num - 1 - circle){ col++; directCount = 0; } else{ direct = 1; directCount++; } break; } case 1:{ if(row != row_num - 1 - circle){ row++; directCount = 0; } else{ direct = 2; directCount++; } break; } case 2:{ if(col != circle){ col--; directCount = 0; } else{ direct = 3; directCount++; } break; } case 3:{ if(row != circle + 1){ row--; directCount = 0; } else{ circle++; direct = 0; directCount++; } } } } return ret; }}; 代码实现（参考设置上下左右边界）： 执行结果 用量 排名 用时 4ms 超过37.74%用户 内存 6.7MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; ret; int row_num = matrix.size(); int col_num; if(row_num){ col_num = matrix[0].size(); } else{ return {}; } int up = 0; int down = row_num - 1; int left = 0; int right = col_num - 1; while(1){ for(int i = left; i &lt;= right; i++){ ret.push_back(matrix[up][i]); } if(++up &gt; down) break; for(int i = up; i &lt;= down; i++){ ret.push_back(matrix[i][right]); } if(--right &lt; left) break; for(int i = right; i &gt;= left; i--){ ret.push_back(matrix[down][i]); } if(--down &lt; up) break; for(int i = down; i &gt;= up; i--){ ret.push_back(matrix[i][left]); } if(++left &gt; right) break; } return ret; }}; 最大子序和 NO.53题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 代码实现（参考动态规划）： 执行结果 用量 排名 用时 4ms 超过97.39%用户 内存 6.9MB 超过100%用户 123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int pre = 0; int MaxNum = nums[0]; for(int x : nums){ pre = max(pre + x, x); MaxNum = max(MaxNum, pre); } return MaxNum; }};","link":"/2020/07/20/LeetCode-Dairy-XII/"},{"title":"LeetCode Dairy XIII","text":"跳跃游戏 NO.55题目描述：给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置 代码实现（原创）： 执行结果 用量 排名 用时 40ms 超过6.31%用户 内存 13MB 超过8.70%用户 1234567891011121314151617181920212223class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); if(!nSize) return true; if(nSize == 1) return true; int arrive_pos = nSize - 1; for(int i = nSize - 2; i &gt;= 0;i--){ int distance = arrive_pos - i; if(nums[i] &gt;= distance){ arrive_pos = i; } } if(arrive_pos == 0){ return true; } else{ return false; } }}; 代码实现（参考贪心算法思想）： 执行结果 用量 排名 用时 28ms 超过19.63%用户 内存 12.8MB 超过8.70%用户 12345678910111213141516class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); int max_step = 0; for(int i = 0;i &lt; nSize; i++){ if(i &gt; max_step){ return false; } max_step = max(max_step , i + nums[i]); if(max_step &gt;= nSize - 1) return true; } return false; }}; 合并区间 NO.56题目描述：给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 代码实现（原创，排序后，暴力法）： 执行结果 用量 排名 用时 92ms 超过12.41%用户 内存 14.9MB 超过28.21%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; ret; int iSize = intervals.size(); if(!iSize) return {}; if(iSize == 1) return intervals; char map[iSize]; memset(map, 0, iSize); sort(intervals.begin(), intervals.end()); for(int i = 0; i &lt; iSize; i++){ if(map[i]) continue; vector&lt;int&gt; seed = intervals[i]; for(int j = i + 1; j &lt; iSize; j++){ if(map[j]) continue; vector&lt;int&gt; mergeResult = mergeTwo(seed, intervals[j]); if(mergeResult.size()){ map[j] = 1; seed = mergeResult; } } ret.push_back(seed); } return ret; } vector&lt;int&gt; mergeTwo(vector&lt;int&gt; a, vector&lt;int&gt; b){ vector&lt;int&gt; ret; int a_left = a[0]; int a_right = a[1]; int b_left = b[0]; int b_right = b[1]; if(a_left &gt;= b_left &amp;&amp; a_left &lt;= b_right){ int c_left = b_left; int c_right = max(b_right, a_right); ret.push_back(c_left); ret.push_back(c_right); return ret; } if(b_left &gt;= a_left &amp;&amp; b_left &lt;= a_right){ int c_left = a_left; int c_right = max(b_right, a_right); ret.push_back(c_left); ret.push_back(c_right); return ret; } return ret; } }; 代码实现（参考双指针方法）： 执行结果 用量 排名 用时 48ms 超过49.71%用户 内存 10.7MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; ret; sort(intervals.begin(), intervals.end()); int iSize = intervals.size(); if(!iSize) return {}; if(1 == iSize) return intervals; int start = intervals[0][0]; int end = intervals[0][1]; for(int i = 1; i &lt; iSize; i++){ int temp_start = intervals[i][0]; int temp_end = intervals[i][1]; if(end &gt;= temp_start){ if(end &lt; temp_end){ end = temp_end; } } else{ vector&lt;int&gt; temp; temp.push_back(start); temp.push_back(end); ret.push_back(temp); start = intervals[i][0]; end = intervals[i][1]; } if(i == iSize - 1){ vector&lt;int&gt; temp; temp.push_back(start); temp.push_back(end); ret.push_back(temp); } } return ret; }}; 最后一个单词的长度 NO.58题目描述：给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.7 MB 超过100%用户 1234567891011121314151617181920class Solution {public: int lengthOfLastWord(string s) { int sSize = s.size(); int count = 0; for(int i = sSize - 1; i &gt;= 0; i--){ if(s[i] == ' '){ if(count){ break; } else{ continue; } } count++; } return count; }}; 螺旋矩阵 II NO.59题目描述：给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 代码实现（参考上下左右边界缩减思想）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 6.9 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int up = 0; int down = n - 1; int left = 0; int right = n - 1; int cur = 1; while(1){ for(int i = left; i &lt;= right; i++){ matrix[up][i] = cur; cur++; } if(++up &gt; down) break; for(int i = up; i &lt;= down; i++){ matrix[i][right] = cur; cur++; } if(--right &lt; left) break; for(int i = right; i &gt;= left; i--){ matrix[down][i] = cur; cur++; } if(--down &lt; up) break; for(int i = down; i &gt;= up; i--){ matrix[i][left] = cur; cur++; } if(++left &gt; right) break; } return matrix; }}; 加一 NO.66题目描述：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 代码实现（原创）： 执行结果 用量 排名 用时 0ms 超过100%用户 内存 9 MB 超过5.88%用户 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int dSize = digits.size(); reverse(digits.begin(), digits.end()); int up = 1; for(int i = 0; i &lt; dSize; i++){ if(!up) break; int sum = up + digits[i]; digits[i] = sum % 10; up = sum / 10; } if(up){ digits.push_back(1); } reverse(digits.begin(), digits.end()); return digits; }};","link":"/2020/07/22/LeetCode-Dairy-XIII/"},{"title":"LeetCode Dairy XIV","text":"第k个排列 NO.60题目描述：给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123”“132”“213”“231”“312”“321”给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 代码实现（原创，根据序号，每次查找开头数字）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过100%用户 1234567891011121314151617181920212223242526class Solution {public: string getPermutation(int n, int k) { if(n == 0) return &quot;&quot;; string cur = &quot;&quot;; int factorialStore[n + 1]; int factorial = 1; vector&lt;int&gt; nums(n, 0); int toFind = k - 1; for(int i = 1; i &lt; n + 1; i++){ factorial *= i; factorialStore[i] = factorial; nums[i - 1] = i; } int count = 0; while(count != n){ int index = toFind / factorialStore[n - 1 - count]; toFind = toFind % factorialStore[n - 1 -count]; cur.push_back(nums[index] + '0'); nums.erase(nums.begin() + index); count++; } return cur; }}; 旋转链表 NO.61题目描述：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 代码实现（原创）： 执行结果 用量 排名 用时 8 ms 超过94.62%用户 内存 7.4 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* pre = new ListNode(1); pre-&gt;next = head; ListNode* front = pre; ListNode* behind = pre; int step = 0; int moved = 0; while(1){ if(k == 0) break; if(step &gt; 0 &amp;&amp; behind-&gt;next == NULL){ if(moved){ break; } else{ k = k % step; step = 0; front = pre; behind = pre; continue; } } behind = behind-&gt;next; if(step &gt;= k){ front = front-&gt;next; moved = 1; } step++; } ListNode *newHead = front-&gt;next; front-&gt;next = NULL; behind-&gt;next = head; delete(pre); return newHead; }}; 不同路径 NO.62题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 代码实现（原创，排列组合）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过100%用户 12345678910111213class Solution {public: int uniquePaths(int m, int n) { m--; n--; long long possible = 1; for(int i = 0; i &lt; n; i++){ possible = possible * (++m); possible = possible / (i+1); } return possible; }}; 代码实现（参考动态方程）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 5.9 MB 超过100%用户 12345678910111213141516class Solution {public: int uniquePaths(int m, int n) { int dp[m][n]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(i == 0 || j == 0){ dp[i][j] = 1; continue; } dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }}; 二进制求和 NO.67题目描述：给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100” 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6.5 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536class Solution {public: string addBinary(string a, string b) { int aSize = a.size(); int bSize = b.size(); int aIndex = aSize - 1; int bIndex = bSize - 1; string ret = &quot;&quot;; char up = 0; while(aIndex &gt;= 0 || bIndex &gt;= 0){ char n1 = 0; char n2 = 0; if(aIndex &gt;= 0){ n1 = a[aIndex] - '0'; aIndex--; } if(bIndex &gt;= 0){ n2 = b[bIndex] - '0'; bIndex--; } char sum = n1 + n2 + up; ret.push_back(sum % 2 + '0'); up = sum / 2; } if(up){ ret.push_back('1'); } reverse(ret.begin(), ret.end()); return ret; }};","link":"/2020/07/23/LeetCode-Dairy-XIV/"},{"title":"LeetCode Dairy XV","text":"不同路径 II NO.63题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 代码实现（原创）： 执行结果 用量 排名 用时 4 ms 超过93.88%用户 内存 7.6 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = obstacleGrid.size(); int m; if(n){ m = obstacleGrid[0].size(); } else{ return 0; } int dp[n][m]; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(i == 0 &amp;&amp; j == 0){ if(obstacleGrid[0][0]){ return 0; } dp[i][j] = 1; continue; } if(obstacleGrid[i][j]){ dp[i][j] = 0; continue; } if(i == 0){ dp[i][j] = dp[i][j - 1]; continue; } if(j == 0){ dp[i][j] = dp[i - 1][j]; continue; } dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[n - 1][m - 1]; }}; 最小路径和 NO.64题目描述：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 代码实现（原创）： 执行结果 用量 排名 用时 8 ms 超过86.83%用户 内存 8.4 MB 超过100%用户 123456789101112131415161718192021222324252627282930class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); if(!n) return 0; int m = grid[0].size(); int dp[n][m]; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(i == 0 &amp;&amp; j == 0){ dp[i][j] = grid[i][j]; continue; } if(i == 0){ dp[i][j] = grid[i][j] + dp[i][j - 1]; continue; } if(j == 0){ dp[i][j] = grid[i][j] + dp[i - 1][j]; continue; } dp[i][j] = grid[i][j] + min(dp[i][j - 1], dp[i - 1][j]); } } return dp[n - 1][m - 1]; }}; 爬楼梯 NO.70题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 代码实现（原创，动态规划）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 5.9 MB 超过100%用户 12345678910111213class Solution {public: int climbStairs(int n) { if(n == 1) return 1; int dp[n]; dp[0] = 1; dp[1] = 2; for(int i = 2; i &lt; n; i++){ dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n - 1]; }}; 删除排序链表中的重复元素 NO.83题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2 代码实现（原创）： 执行结果 用量 排名 用时 16 ms 超过67.84%用户 内存 7.7 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return NULL; if(head-&gt;next == NULL) return head; ListNode* front = head-&gt;next; ListNode* behind = head; while(front-&gt;next){ if(front-&gt;val != behind-&gt;val){ if(behind-&gt;next != front){ behind-&gt;next = front; } front = front-&gt;next; behind = behind-&gt;next; } else{ front = front-&gt;next; } } if(front-&gt;val == behind-&gt;val){ behind-&gt;next = NULL; } else if(behind-&gt;next != front){ behind-&gt;next = front; } return head; }}; 合并两个有序数组 NO.88题目描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 代码实现（原创, 正序操作）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 9.5 MB 超过6.06%用户 123456789101112131415161718192021222324252627282930313233class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int n1 = 0; int n2 = 0; vector&lt;int&gt; nums3 = nums1; int count = 0; while(n1 != m || n2 != n){ if(n1 &lt; m &amp;&amp; n2 &lt; n){ if(nums3[n1] &lt; nums2[n2]){ nums1[count] = nums3[n1]; n1++; } else{ nums1[count] = nums2[n2]; n2++; } } else{ if(n1 &lt; m){ nums1[count] = nums3[n1]; n1++; } if(n2 &lt; n){ nums1[count] = nums2[n2]; n2++; } } count++; } }}; 代码实现（参考倒序）： 执行结果 用量 排名 用时 4 ms 超过80.66%用户 内存 9.2 MB 超过6.06%用户 1234567891011121314151617181920212223242526272829303132class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int n1 = m - 1; int n2 = n - 1; int count = m + n - 1; while(n1 &gt;= 0 || n2 &gt;= 0){ if(n1 &gt;= 0 &amp;&amp; n2 &gt;= 0){ if(nums1[n1] &gt; nums2[n2]){ nums1[count] = nums1[n1]; n1--; } else{ nums1[count] = nums2[n2]; n2--; } } else{ if(n1 &gt;= 0){ nums1[count] = nums1[n1]; n1--; } if(n2 &gt;= 0){ nums1[count] = nums2[n2]; n2--; } } count--; } }};","link":"/2020/07/24/LeetCode-Dairy-XV/"},{"title":"LeetCode Dairy XVI","text":"简化路径 NO.71题目描述：以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1： 输入：”/home/“输出：”/home”解释：注意，最后一个目录名后面没有斜杠。 代码实现（原创）： 执行结果 用量 排名 用时 12 ms 超过64.43%用户 内存 7.9 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: string simplifyPath(string path) { vector&lt;string&gt; pathStruct; string current = &quot;&quot;; path += &quot;/&quot;; for(int i = 0; i &lt; path.size(); i++){ if(i == 0){ if(path[i] != '/') return &quot;&quot;; continue; } if(path[i] == '/'){ if(current == &quot;&quot;){ continue; } if(current == &quot;.&quot;){ current = &quot;&quot;; continue; } else if(current == &quot;..&quot;){ if(!pathStruct.empty()) pathStruct.pop_back(); } else{ pathStruct.push_back(current); } current = &quot;&quot;; }else{ current += path[i]; } } if(pathStruct.empty()) return &quot;/&quot;; string ret; for(string s : pathStruct){ ret += &quot;/&quot;; ret += s; } return ret; }}; 矩阵置零 NO.73题目描述：给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 输入:[ [1,1,1], [1,0,1], [1,1,1]]输出:[ [1,0,1], [0,0,0], [1,0,1]] 代码实现（原创，暴力法）： 执行结果 用量 排名 用时 36 ms 超过43.49%用户 内存 13.3 MB 超过5.26%用户 1234567891011121314151617181920212223242526272829class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int nSize = matrix.size(); if(!nSize) return; int mSize = matrix[0].size(); bool nFlag[nSize]; memset(nFlag, 0, nSize); bool mFlag[mSize]; memset(mFlag, 0, mSize); for(int i = 0; i &lt; nSize; i++){ for(int j = 0; j &lt; mSize; j++){ if(matrix[i][j] == 0){ nFlag[i] = 1; mFlag[j] = 1; } } } for(int i = 0; i &lt; nSize; i++){ for(int j = 0; j &lt; mSize; j++){ if(nFlag[i] || mFlag[j]) { matrix[i][j] = 0; } } } }}; 代码实现（参考第一行，第一列作标记）： 执行结果 用量 排名 用时 28 ms 超过85.09%用户 内存 13.3 MB 超过5.26%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int nSize = matrix.size(); if(!nSize) return; int mSize = matrix[0].size(); bool flag = 1; for(int i = 0; i &lt; nSize; i++){ if(matrix[i][0] == 0) flag = 0; for(int j = 1; j &lt; mSize; j++){ if(matrix[i][j] == 0){ matrix[0][j] = 0; matrix[i][0] = 0; } } } for(int i = 1; i &lt; nSize; i++){ if(matrix[i][0] == 0){ for(int j = 1; j &lt; mSize; j++){ matrix[i][j] = 0; } } } for(int i = 1; i &lt; mSize; i++){ if(matrix[0][i] == 0){ for(int j = 1; j &lt; nSize; j++){ matrix[j][i] = 0; } } } if(matrix[0][0] == 0){ for(int j = 1; j &lt; mSize; j++){ matrix[0][j] = 0; } } if(flag == 0){ for(int i = 0;i &lt; nSize; i++){ matrix[i][0] = 0; } } }}; 搜索二维矩阵 NO.74题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。示例 1: 输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 代码实现（原创，矩阵二分查找）： 执行结果 用量 排名 用时 4 ms 超过99.36%用户 内存 7.7 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int n = matrix.size(); if(!n) return false; int m = matrix[0].size(); if(!m) return false; int rowBegin = 0; int rowEnd = n - 1; int colBegin = 0; int colEnd = m - 1; while(rowBegin &lt;= rowEnd){ int rowMid = (rowBegin + rowEnd) / 2; if(matrix[rowMid][0] &gt; target){ rowEnd = rowMid - 1; continue; } if(matrix[rowMid][m - 1] &lt; target){ rowBegin = rowMid + 1; continue; } while(colBegin &lt;= colEnd){ int colMid = (colBegin + colEnd) / 2; if(matrix[rowMid][colMid] == target){ return true; } if(matrix[rowMid][colMid] &gt; target){ colEnd = colMid - 1; continue; } if(matrix[rowMid][colMid] &lt; target){ colBegin = colMid + 1; continue; } } break; } return false; }}; 颜色分类 NO.75题目描述：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 代码实现（原创，三指针）： 执行结果 用量 排名 用时 4 ms 超过55.84%用户 内存 8.3 MB 超过100%用户 123456789101112131415161718192021222324252627282930class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); int behindIndex = nSize - 1; int frontIndex = 0; int current = 0; while(current &lt;= behindIndex){ if(nums[current] == 0){ if(frontIndex == current){ current++; continue; } int temp = nums[frontIndex]; nums[frontIndex] = 0; nums[current] = temp; frontIndex++; } else if(nums[current] == 1){ current++; } else if(nums[current] == 2){ int temp = nums[behindIndex]; nums[behindIndex] = 2; nums[current] = temp; behindIndex--; } } }}; 组合 NO.77题目描述：给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 代码实现（原创，递归深度遍历）： 执行结果 用量 排名 用时 40 ms 超过74.09%用户 内存 9.3 MB 超过100%用户 123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; toCombine(cur, n, k, 1, ret); return ret; } void toCombine(vector&lt;int&gt; &amp;current, int n,int k, int index,vector&lt;vector&lt;int&gt;&gt; &amp;result){ if(current.size() == k){ result.push_back(current); return; } for(int i = index; i &lt; n + 1; i++){ current.push_back(i); toCombine(current, n, k, i + 1, result); current.pop_back(); } }};","link":"/2020/07/27/LeetCode-Dairy-XVI/"},{"title":"LeetCode Dairy XVII","text":"子集 NO.78题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6.9 MB 超过100%用户 123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ret; ret.push_back({}); vector&lt;int&gt; cur; toFind(cur, nums, 0, ret); return ret; } void toFind(vector&lt;int&gt; &amp;current, vector&lt;int&gt; &amp;nums, int index, vector&lt;vector&lt;int&gt;&gt; &amp;result){ if(index == nums.size()) return; for(int i = index; i &lt; nums.size(); i++){ current.push_back(nums[i]); result.push_back(current); toFind(current, nums, i + 1, result); current.pop_back(); } }}; 单词搜索 NO.79题目描述：给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 代码实现（原来的代码超时，后修改为如果发现成功解答，立即返回，不再进行多余尝试）： 执行结果 用量 排名 用时 36 ms 超过66.11%用户 内存 9 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { rowSize = board.size(); if(!rowSize) return false; colSize = board[0].size(); wordToFind = word; int ret = 0; vector&lt;vector&lt;bool&gt;&gt; store(rowSize, vector&lt;bool&gt;(colSize)); for(int i = 0; i &lt; rowSize; i++){ for(int j = 0; j &lt; colSize; j++){ if(board[i][j] == word[0]){ store[i][j] = 1; toFind(board, 1, i, j, store, ret); store[i][j] = 0; } if(ret) return true; } } return ret; } void toFind(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index, int row, int col, vector&lt;vector&lt;bool&gt;&gt; &amp;storage, int &amp;result){ if(index == wordToFind.size()){ result++; return; } if(row - 1 &gt;= 0 &amp;&amp; !storage[row - 1][col] &amp;&amp; board[row - 1][col] == wordToFind[index]){ storage[row - 1][col] = 1; toFind(board, index + 1, row - 1, col, storage, result); if(result) return; storage[row - 1][col] = 0; } if(col - 1 &gt;= 0 &amp;&amp; !storage[row][col - 1] &amp;&amp; board[row][col - 1] == wordToFind[index]){ storage[row][col - 1] = 1; toFind(board, index + 1, row, col - 1, storage, result); if(result) return; storage[row][col - 1] = 0; } if(row + 1 &lt; rowSize &amp;&amp; !storage[row + 1][col] &amp;&amp; board[row + 1][col] == wordToFind[index]){ storage[row + 1][col] = 1; toFind(board, index + 1, row + 1, col, storage, result); if(result) return; storage[row + 1][col] = 0; } if(col + 1 &lt; colSize &amp;&amp; !storage[row][col + 1] &amp;&amp; board[row][col + 1] == wordToFind[index]){ storage[row][col + 1] = 1; toFind(board, index + 1, row, col + 1, storage, result); if(result) return; storage[row][col + 1] = 0; } return; } int rowSize; int colSize; string wordToFind;}; 代码实现（参考优化代码，改变使用过的矩阵值，防止重复）： 执行结果 用量 排名 用时 20 ms 超过98.94%用户 内存 7.6 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { rowSize = board.size(); if(!rowSize) return false; colSize = board[0].size(); wordToFind = word; for(int i = 0; i &lt; rowSize; i++){ for(int j = 0; j &lt; colSize; j++){ if(toFind(board, 0, i, j)) return true; } } return false; } bool toFind(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index, int row, int col){ if(index == wordToFind.size()){ return true; } if(row &lt; 0 || row &gt;= rowSize || col &lt; 0 || col &gt;= colSize || board[row][col] != wordToFind[index]) return false; board[row][col] += 128; bool f = toFind(board, index + 1, row - 1, col)|| toFind(board, index + 1, row, col - 1)|| toFind(board, index + 1, row + 1, col)|| toFind(board, index + 1, row, col + 1); board[row][col] -= 128; return f; } int rowSize; int colSize; string wordToFind;}; 删除排序数组中的重复项 II NO.80题目描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 代码实现（原创）： 执行结果 用量 排名 用时 8 ms 超过95.86%用户 内存 6.4 MB 超过100%用户 123456789101112131415161718192021222324class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); if(!nSize) return 0; int lastInt = nums[0]; int count = 1; int index = 1; for(int i = 1; i &lt; nSize; i++){ if(lastInt == nums[i]){ count++; } else{ count = 1; lastInt = nums[i]; } if(count &lt;= 2){ nums[index++] = nums[i]; } } return index; }}; 分隔链表 NO.86题目描述：给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 代码实现（原创，三指针）： 执行结果 用量 排名 用时 4 ms 超过98.59%用户 内存 6.9 MB 超过100%用户 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* partition(ListNode* head, int x) { if(!head) return NULL; if(!head-&gt;next) return head; ListNode* newHead = new ListNode(1); newHead-&gt;next = head; ListNode* newLink = newHead; ListNode* pre = newHead; ListNode* current = head; while(current){ if(current-&gt;val &lt; x &amp;&amp; newLink != pre){ ListNode* temp = current-&gt;next; pre-&gt;next = current-&gt;next; ListNode* temp2 = newLink-&gt;next; newLink-&gt;next = current; current-&gt;next = temp2; current = temp; newLink = newLink-&gt;next; } else{ if(current-&gt;val &lt; x) newLink = newLink-&gt;next; pre = pre-&gt;next; current = current-&gt;next; } } ListNode* ret = newHead-&gt;next; delete(newHead); return ret; }};","link":"/2020/07/28/LeetCode-Dairy-XVII/"},{"title":"LeetCode Dairy XVIII","text":"搜索旋转排序数组 II NO.81题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 代码实现（原创， 二分查找 + 递归）： 执行结果 用量 排名 用时 8 ms 超过46.10%用户 内存 6.5 MB 超过100%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: int rightVal; int leftVal; bool search(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize) return false; int left = 0; int right = nSize - 1; leftVal = nums[0]; rightVal = nums[nSize - 1]; if(target == leftVal || target == rightVal) return true; if(target &lt; leftVal &amp;&amp; target &gt; rightVal) return false; return toSearch(left, right, target, nums); } bool toSearch(int left, int right, int &amp;target, vector&lt;int&gt;&amp; nums){ while(left &lt;= right){ int mid = (left + right) / 2; if(target == nums[mid]) return true; if(rightVal == leftVal &amp;&amp; nums[mid] == rightVal){ bool ret = toSearch(mid + 1, right, target, nums) || toSearch(left, mid - 1, target, nums); if(ret) return true; } if(nums[mid] &lt;= rightVal){ // mid in right if(target &gt; nums[mid]){ if(target &lt; rightVal){ left = mid + 1; } else{ right = mid - 1; } } else{ right = mid - 1; } } else{ //mid in left if(target &gt; nums[mid]){ left = mid + 1; } else{ if(target &lt; rightVal){ left = mid + 1; } else{ right = mid - 1; } } } } return false; }}; 代码实现（参考边界缩减）： 执行结果 用量 排名 用时 4 ms 超过97.06%用户 内存 6.5 MB 超过100%用户 123456789101112131415161718192021222324252627class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int nSize = nums.size(); if(!nSize) return false; int left = 0; int right = nSize - 1; while(left &lt;= right){ int mid = (left + right) / 2; if(target == nums[mid]) return true; if(nums[mid] == nums[left] &amp;&amp; nums[mid] == nums[right]){ left++; right--; continue; } if(target &gt; nums[mid]){ if(nums[mid] &lt;= nums[right] &amp;&amp; target &gt; nums[right]) right = mid - 1; else left = mid + 1; } else{ if(nums[mid] &gt; nums[right] &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; } } return false; }}; 删除排序链表中的重复元素 II NO.82题目描述：给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 代码实现（原创）： 执行结果 用量 排名 用时 8 ms 超过93.41%用户 内存 7.2 MB 超过100%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return NULL; ListNode* newHead = new ListNode(1); ListNode* newLink = newHead; ListNode* current = head; int lastValue; int count = 1; while(current-&gt;next){ lastValue = current-&gt;val; ListNode* temp = current-&gt;next; if(current-&gt;val == temp-&gt;val){ delete(current); count++; } else{ if(count == 1) { current-&gt;next = NULL; newLink-&gt;next = current; newLink = newLink-&gt;next; }else{ delete(current); } count = 1; } current = temp; } if(lastValue != current-&gt;val){ newLink-&gt;next = current; } ListNode* ret = newHead-&gt;next; delete(newHead); return ret; }}; 格雷编码 NO.89题目描述：格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。 格雷编码序列必须以 0 开头。 示例 1: 输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2 代码实现（参考镜像反射）： 执行结果 用量 排名 用时 4 ms 超过45.64%用户 内存 6.7 MB 超过100%用户 123456789101112131415class Solution {public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; ret; ret.push_back(0); for(int i = 0; i &lt; n ; i++){ vector&lt;int&gt; temp = ret; for(int j = temp.size() - 1; j &gt;=0; j--){ int k = temp[j] + (1&lt;&lt;i); ret.push_back(k); } } return ret; }};","link":"/2020/07/29/LeetCode-Dairy-XVIII/"},{"title":"LeetCode Dairy XIX","text":"子集 II NO.90题目描述：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.3 MB 超过64.29%用户 1234567891011121314151617181920212223242526class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ret; ret.push_back({}); vector&lt;int&gt; cur; sort(nums.begin(), nums.end()); toFind(cur, nums, 0, ret); return ret; } void toFind(vector&lt;int&gt;&amp; current, vector&lt;int&gt;&amp; nums, int index,vector&lt;vector&lt;int&gt;&gt;&amp; result){ if(index == nums.size()) return; int lastNum; for(int i = index; i &lt; nums.size(); i++){ if(i &gt; index &amp;&amp; lastNum == nums[i]){ continue; } lastNum = nums[i]; current.push_back(nums[i]); result.push_back(current); toFind(current, nums, i + 1, result); current.pop_back(); } }}; 反转链表 II NO.92题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 代码实现（原创）： 执行结果 用量 排名 用时 4 ms 超过65.35%用户 内存 6.8 MB 超过5.06%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { if(!head) return NULL; if(!head-&gt;next) return head; ListNode* newHead = new ListNode(1); newHead-&gt;next = head; ListNode* before, *after, *first, *last, *fina, *current; current = newHead; int index = 0; int flag = 0; while(current){ ListNode* temp = current-&gt;next; if(flag == 1){ current-&gt;next = last; } if(flag == 2){ //current = temp; break; } if(m == index){ before = last; first = current; flag = 1; } if(n == index){ fina = current; flag = 2; } last = current; current = temp; index++; } before-&gt;next = fina; first-&gt;next = current; return newHead-&gt;next; }}; 代码实现（参考递归反转）： 执行结果 用量 排名 用时 4 ms 超过65.35%用户 内存 6.6 MB 超过21.52%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* behind; int count; ListNode* reverseBetween(ListNode* head, int m, int n) { if(!head) return NULL; if(!head-&gt;next) return head; ListNode* dummy = new ListNode(1); dummy-&gt;next = head; ListNode* current = dummy; for(int i = 1; i &lt; m; i++){ current = current-&gt;next; } count = n - m + 1; current-&gt;next = toReverse(current-&gt;next, count); return dummy-&gt;next; } ListNode* toReverse(ListNode* head, int k){ if(!head-&gt;next) { behind = NULL; return head; } if(k == 1){ behind = head-&gt;next; return head; } ListNode* last = toReverse(head-&gt;next, k - 1); head-&gt;next-&gt;next = head; head-&gt;next = NULL; if(k == count) { head-&gt;next = behind; } return last; }}; 代码实现（递归代码简化）： 执行结果 用量 排名 用时 4 ms 超过65.35%用户 内存 6.5 MB 超过62.03%用户 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* behind; ListNode* reverseBetween(ListNode* head, int m, int n) { if(m == 1){ return toReverse(head, n); } head-&gt;next = reverseBetween(head-&gt;next, m - 1, n - 1); return head; } ListNode* toReverse(ListNode* head, int k){ if(k == 1){ behind = head-&gt;next; return head; } ListNode* last = toReverse(head-&gt;next, k - 1); head-&gt;next-&gt;next = head; head-&gt;next = behind; return last; }}; 代码实现（最简化）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6.5 MB 超过77.22%用户 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* behind; ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* current = dummy; for(int i = 1; i &lt; m; i++){ current = current-&gt;next; } ListNode* pre = current; current = current-&gt;next; for(int i = m; i &lt; n; i++){ ListNode* temp = current-&gt;next; current-&gt;next = temp-&gt;next; temp-&gt;next = pre-&gt;next; pre-&gt;next = temp; } return dummy-&gt;next; } }; 复原IP地址 NO.93题目描述：给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。 代码实现（原创，递归）： 执行结果 用量 排名 用时 4 ms 超过81.65%用户 内存 7.4 MB 超过7.69%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: int strSize; vector&lt;string&gt; restoreIpAddresses(string s) { vector&lt;string&gt; ret; string cur = &quot;&quot;; strSize = s.size(); toFind(cur, 0, 0, s, ret); return ret; } void toFind(string current, int index, int count, string&amp; s, vector&lt;string&gt;&amp; result){ if(count == 4){ if(index == strSize){ current.pop_back(); result.push_back(current); } return; } if(index &gt;= strSize) return; if(strSize - index &gt;= 3 &amp;&amp; s[index] != '0'){ string str = s.substr(index, 3); if(stoi(str) &lt;= 255){ current += str + &quot;.&quot;; toFind(current, index + 3, count + 1, s, result); current.erase(current.end() - 4, current.end()); } } if(strSize - index &gt;= 2 &amp;&amp; s[index] != '0'){ string str = s.substr(index, 2); current += str + &quot;.&quot;; toFind(current, index + 2, count + 1, s, result); current.erase(current.end() - 3, current.end()); } if(strSize - index &gt;= 1){ string str = s.substr(index, 1); current += str + &quot;.&quot;; toFind(current, index + 1, count + 1, s, result); current.erase(current.end() - 2, current.end()); } }};","link":"/2020/07/30/LeetCode-Dairy-XIX/"},{"title":"LeetCode Dairy XXIII","text":"二叉树的锯齿形层次遍历 NO.103题目描述：给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 代码实现（原创，栈）： 执行结果 用量 排名 用时 0 ms 超过100 %用户 内存 11.6 MB 超过10.54 %用户 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; ret; stack&lt;TreeNode*&gt; nodeStore; if(!root) return ret; nodeStore.push(root); bool direct = 1; //1: right to left; 0: left to right; while(!nodeStore.empty()){ int sSize = nodeStore.size(); ret.push_back(vector&lt;int&gt;()); stack&lt;TreeNode*&gt; nodeTemp; for(int i = 0; i &lt; sSize; i++){ TreeNode* temp = nodeStore.top(); nodeStore.pop(); ret.back().push_back(temp-&gt;val); if(!direct){ if(temp-&gt;right) nodeTemp.push(temp-&gt;right); if(temp-&gt;left) nodeTemp.push(temp-&gt;left); } else{ if(temp-&gt;left) nodeTemp.push(temp-&gt;left); if(temp-&gt;right) nodeTemp.push(temp-&gt;right); } } direct = !direct; nodeStore = nodeTemp; } return ret; }}; 代码实现（原创，链表）： 执行结果 用量 排名 用时 4 ms 超过74.16 %用户 内存 11.7 MB 超过10.54 %用户 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; ret; list&lt;TreeNode*&gt; nodeStore; if(!root) return ret; nodeStore.push_back(root); bool direct = 1; while(!nodeStore.empty()){ int sSize = nodeStore.size(); ret.push_back(vector&lt;int&gt;()); for(int i = 0; i &lt; sSize; i++){ if(direct){ TreeNode* temp = nodeStore.back(); nodeStore.pop_back(); ret.back().push_back(temp-&gt;val); if(temp-&gt;left) nodeStore.push_front(temp-&gt;left); if(temp-&gt;right) nodeStore.push_front(temp-&gt;right); } else{ TreeNode* temp = nodeStore.front(); nodeStore.pop_front(); ret.back().push_back(temp-&gt;val); if(temp-&gt;right) nodeStore.push_back(temp-&gt;right); if(temp-&gt;left) nodeStore.push_back(temp-&gt;left); } } direct = !direct; } return ret; }}; 二叉树的最大深度 NO.104题目描述：给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 代码实现（原创，递归）： 执行结果 用量 排名 用时 12 ms 超过65.94 %用户 内存 16.9 MB 超过84.90 %用户 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int depthMax = 0; int maxDepth(TreeNode* root) { toDig(root, 0); return depthMax; } void toDig(TreeNode* root, int depth){ depthMax = max(depth, depthMax); if(!root) return; toDig(root-&gt;left, depth + 1); toDig(root-&gt;right, depth + 1); }}; 代码实现（简化）： 执行结果 用量 排名 用时 16 ms 超过30.79 %用户 内存 17 MB 超过52.97 %用户 12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(!root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; }}; 二叉树的层次遍历 II NO.107题目描述：给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。 代码实现（原创，逆置）： 执行结果 用量 排名 用时 8 ms 超过56.50 %用户 内存 11.4 MB 超过99.65 %用户 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; ret; queue&lt;TreeNode*&gt; nodeQ; if(!root) return ret; nodeQ.push(root); while(!nodeQ.empty()){ int nSize = nodeQ.size(); ret.push_back(vector&lt;int&gt;()); for(int i = 0; i &lt; nSize; i++){ TreeNode* node = nodeQ.front(); nodeQ.pop(); ret.back().push_back(node-&gt;val); if(node-&gt;left) nodeQ.push(node-&gt;left); if(node-&gt;right) nodeQ.push(node-&gt;right); } } reverse(ret.begin(), ret.end()); return ret; }}; 二叉树的最小深度 NO.111题目描述：给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 代码实现（原创，递归）： 执行结果 用量 排名 用时 16 ms 超过53.02 %用户 内存 17.5 MB 超过34.05 %用户 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int depthMin = 0; int minDepth(TreeNode* root) { toDig(root, 0); return depthMin; } void toDig(TreeNode* root, int depth){ if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right){ depthMin = depthMin ? min(depthMin, depth + 1) : depth + 1; return; } toDig(root-&gt;left, depth + 1); toDig(root-&gt;right, depth + 1); }}; 代码实现（递归简化版）： 执行结果 用量 排名 用时 12 ms 超过83.86 %用户 内存 17.5 MB 超过30.76 %用户 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int minDepth(TreeNode* root) { if(!root) return 0; return (root-&gt;left &amp;&amp; root-&gt;right) ? min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1 : 1 + minDepth(root-&gt;left) + minDepth(root-&gt;right); }};","link":"/2020/08/07/LeetCode-Dairy-XXIII/"},{"title":"LeetCode Dairy XXIV","text":"有序链表转换二叉搜索树 NO.109题目描述：给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 代码实现（在链表上操作）： 执行结果 用量 排名 用时 44 ms 超过78.31%用户 内存 29.5 MB 超过51.87%用户 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; *//** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedListToBST(ListNode* head) { if(!head) return NULL; if(!head-&gt;next){ return new TreeNode(head-&gt;val); } ListNode* pre = head; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next){ pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } pre-&gt;next = NULL; TreeNode* rootNode = new TreeNode(slow-&gt;val); rootNode-&gt;left = sortedListToBST(head); rootNode-&gt;right = sortedListToBST(slow-&gt;next); return rootNode; }}; 代码实现（原创，转存到数组）： 执行结果 用量 排名 用时 48 ms 超过60.47%用户 内存 29.8 MB 超过28.22%用户 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; *//** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedListToBST(ListNode* head) { vector&lt;int&gt; nums; while(head){ nums.push_back(head-&gt;val); head = head-&gt;next; } int nSize = nums.size(); return toBuild(nums, 0, nSize - 1); } TreeNode* toBuild(vector&lt;int&gt;&amp; nums, int start, int end){ if(start &gt; end) return NULL; int rootIndex = (start + end + 1) / 2; int root = nums[rootIndex]; TreeNode* rootNode = new TreeNode(root); rootNode-&gt;left = toBuild(nums, start, rootIndex - 1); rootNode-&gt;right = toBuild(nums, rootIndex + 1, end); return rootNode; }}; 代码实现（模拟中序遍历）： 执行结果 用量 排名 用时 48 ms 超过60.47%用户 内存 29.4 MB 超过68.26%用户 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; *//** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: ListNode* rHead; TreeNode* sortedListToBST(ListNode* head) { int lSize = 0; rHead = head; while(head){ head = head-&gt;next; lSize++; } return toBuild(0, lSize - 1); } TreeNode* toBuild(int start, int end){ if(start &gt; end) return NULL; int mid = (start + end + 1) / 2; TreeNode* left = toBuild(start, mid - 1); TreeNode* root = new TreeNode(rHead-&gt;val); rHead = rHead-&gt;next; root-&gt;left = left; root-&gt;right = toBuild(mid + 1, end); return root; }}; 从前序与中序遍历序列构造二叉树 NO.105题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 代码实现（递归）： 执行结果 用量 排名 用时 20 ms 超过89.41%用户 内存 17.7 MB 超过52.17%用户 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: map&lt;int, int&gt; inMap; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int preLen = preorder.size(); int inLen = inorder.size(); for(int i = 0; i &lt; inLen; i++){ inMap[inorder[i]] = i; } return toBuild(preorder, 0, preLen - 1, 0, inLen - 1); } TreeNode* toBuild(vector&lt;int&gt;&amp; preorder, int preLeft, int preRight, int inLeft, int inRight){ if(preLeft &gt; preRight || inLeft &gt; inRight) return NULL; int root = preorder[preLeft]; TreeNode *rootNode = new TreeNode(root); int pIndex = inMap[root]; rootNode-&gt;left = toBuild(preorder, preLeft + 1, preLeft + pIndex - inLeft, inLeft, pIndex - 1); rootNode-&gt;right = toBuild(preorder, preLeft + pIndex - inLeft + 1, preRight, pIndex + 1, inRight); return rootNode; }}; 从中序与后序遍历序列构造二叉树 NO.106题目描述：根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 代码实现（递归）： 执行结果 用量 排名 用时 24 ms 超过78.96%用户 内存 18 MB 超过26.03%用户 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: map&lt;int ,int&gt; inMap; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { int postLen = postorder.size(); int inLen = inorder.size(); for(int i = 0; i &lt; inLen; i++){ inMap[inorder[i]] = i; } return toBuild(postorder, 0, postLen - 1, 0, inLen - 1); } TreeNode* toBuild(vector&lt;int&gt;&amp; postorder, int postLeft, int postRight, int inLeft, int inRight){ if(postLeft &gt; postRight || inLeft &gt; inRight) return NULL; int root = postorder[postRight]; TreeNode* rootNode = new TreeNode(root); int pIndex = inMap[root]; rootNode-&gt;left = toBuild(postorder, postLeft, postLeft + pIndex - inLeft - 1, inLeft, pIndex - 1); rootNode-&gt;right = toBuild(postorder, postLeft + pIndex - inLeft, postRight - 1, pIndex + 1, inRight); return rootNode; }}; 将有序数组转换为二叉搜索树 NO.108题目描述：将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 代码实现（原创，递归）： 执行结果 用量 排名 用时 36 ms 超过28.73%用户 内存 23.1 MB 超过78.27%用户 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { int nSize = nums.size(); return toBuild(nums, 0 , nSize - 1); } TreeNode* toBuild(vector&lt;int&gt;&amp; nums, int start, int end){ if(start &gt; end) return NULL; int rootIndex = (start + end) / 2; int root = nums[rootIndex]; TreeNode* rootNode = new TreeNode(root); rootNode-&gt;left = toBuild(nums, start, rootIndex - 1); rootNode-&gt;right = toBuild(nums, rootIndex + 1, end); return rootNode; }};","link":"/2020/08/10/LeetCode-Dairy-XXIV/"},{"title":"LeetCode Dairy XX","text":"二叉树的中序遍历 NO.94题目描述：给定一个二叉树，返回它的中序 遍历。 代码实现（原创，递归）： 执行结果 用量 排名 用时 0 ms 超过100 %用户 内存 7 MB 超过90.92%用户 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; toTravel(root, ret); return ret; } void toTravel(TreeNode* root, vector&lt;int&gt;&amp; result){ if(!root) return; toTravel(root-&gt;left, result); result.push_back(root-&gt;val); toTravel(root-&gt;right, result); }}; 代码实现（参考迭代）： 执行结果 用量 排名 用时 4 ms 超过45.32%用户 内存 7.2 MB 超过56.81%用户 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; rootStack; while(root != NULL || !rootStack.empty()){ if(root){ rootStack.push(root); root = root-&gt;left; } else{ root = rootStack.top(); rootStack.pop(); ret.push_back(root-&gt;val); root = root-&gt;right; } } return ret; }}; 二叉树的前序遍历 NO.144题目描述：给定一个二叉树，返回它的 前序 遍历。 代码实现（原创，递归）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 8.5 MB 超过59.85%用户 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; toTravel(root, ret); return ret; } void toTravel(TreeNode* root, vector&lt;int&gt;&amp; result){ if(!root) return; result.push_back(root-&gt;val); toTravel(root-&gt;left, result); toTravel(root-&gt;right, result); }}; 代码实现（参考迭代）： 执行结果 用量 排名 用时 4 ms 超过49.45%用户 内存 8.8 MB 超过21.08%用户 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; rootStack; while(root != NULL || !rootStack.empty()){ if(root){ ret.push_back(root-&gt;val); rootStack.push(root); root = root-&gt;left; } else{ root = rootStack.top(); rootStack.pop(); root = root-&gt;right; } } return ret; }}; 二叉树的后序遍历 NO.145题目描述：给定一个二叉树，返回它的 后序 遍历。 代码实现（原创，递归）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 8.5 MB 超过66.05%用户 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; toTravel(root, ret); return ret; } void toTravel(TreeNode* root, vector&lt;int&gt;&amp; result){ if(!root) return; toTravel(root-&gt;left, result); toTravel(root-&gt;right, result); result.push_back(root-&gt;val); }}; 代码实现（参考，先根逆置）： 执行结果 用量 排名 用时 4 ms 超过48.82%用户 内存 8.4 MB 超过92.77%用户 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; rootStack; while(root != NULL || !rootStack.empty()){ if(root){ ret.push_back(root-&gt;val); rootStack.push(root); root = root-&gt;right; } else{ root = rootStack.top(); rootStack.pop(); root = root-&gt;left; } } reverse(ret.begin(), ret.end()); return ret; }}; 代码实现（参考模拟递归调用栈）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 8.4 MB 超过92.77%用户 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; rootStack; if(root) rootStack.push(root); while(!rootStack.empty()){ TreeNode* tr = rootStack.top(); rootStack.pop(); if(tr != NULL){ rootStack.push(tr); rootStack.push(NULL); if(tr-&gt;right) rootStack.push(tr-&gt;right); if(tr-&gt;left) rootStack.push(tr-&gt;left); } else{ ret.push_back(rootStack.top()-&gt;val); rootStack.pop(); } } return ret; }}; 代码实现（参考正常迭代后序遍历）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 8.6 MB 超过64.20%用户 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; rootStack; TreeNode* lastNode; while(root != NULL || !rootStack.empty()){ if(root){ rootStack.push(root); root = root-&gt;left; } else{ root = rootStack.top(); if(!root-&gt;right || root-&gt;right == lastNode){ ret.push_back(root-&gt;val); lastNode = root; rootStack.pop(); root = NULL; } else{ root = root-&gt;right; } } } return ret; }};","link":"/2020/08/03/LeetCode-Dairy-XX/"},{"title":"LeetCode Dairy XXI","text":"不同的二叉搜索树 II NO.95题目描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树。 代码实现（参考递归分治）： 执行结果 用量 排名 用时 8 ms 超过99.92%用户 内存 13.7 MB 超过82.14 %用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;TreeNode*&gt; generateTrees(int n) { vector&lt;TreeNode*&gt; ret; if(n == 0) return ret; ret = getTree(1,n); return ret; } vector&lt;TreeNode*&gt; getTree(int start, int end){ vector&lt;TreeNode*&gt; ret; if(start &gt; end){ ret.push_back(NULL); return ret; } if(start == end){ TreeNode* root = new TreeNode(start); ret.push_back(root); return ret; } for(int i = start; i &lt;= end; i++){ vector&lt;TreeNode*&gt; leftTrees = getTree(start, i - 1); vector&lt;TreeNode*&gt; rightTrees = getTree(i + 1, end); for(TreeNode* left : leftTrees){ for(TreeNode* right : rightTrees){ TreeNode* root = new TreeNode(i); root-&gt;left = left; root-&gt;right = right; ret.push_back(root); } } } return ret; }}; 不同的二叉搜索树 NO.96题目描述：给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 代码实现（参考递归分治方式）： 执行结果 用量 排名 用时 0 ms 超过100 %用户 内存 5.8 MB 超过100 %用户 123456789101112131415class Solution {public: int numTrees(int n) { int count[n + 1]; memset(count, 0, sizeof(int) * (n + 1)); count[0] = 1; count[1] = 1; for(int i = 2; i &lt;=n ; i++){ for(int j = 1; j &lt;=i ; j++){ count[i] += count[j - 1] * count[i - j]; } } return count[n]; }}; 验证二叉搜索树 NO.98题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 代码实现（原创，二叉搜索树中序遍历升序）： 执行结果 用量 排名 用时 12 ms 超过92 %用户 内存 18.5 MB 超过22.44 %用户 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { stack&lt;TreeNode*&gt; rootStack; int flag = 0; int lastNum; while(root || !rootStack.empty()){ if(root){ rootStack.push(root); root = root-&gt;left; } else{ root = rootStack.top(); rootStack.pop(); if(flag){ if(root-&gt;val &lt;= lastNum) return false; } else{ flag = 1; } lastNum = root-&gt;val; root = root-&gt;right; } } return true; }}; 代码实现（原创，递归）： 执行结果 用量 排名 用时 20 ms 超过35.38%用户 内存 18.2 MB 超过61.68%用户 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool flag; int lastNum; bool isValidBST(TreeNode* root) { if(!root) return true; if(!isValidBST(root-&gt;left)) return false; if(flag &amp;&amp; root-&gt;val &lt;= lastNum) return false; flag = 1; lastNum = root-&gt;val; if(!isValidBST(root-&gt;right)) return false; return true; }}; 相同的树 NO.100题目描述：给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 代码实现（原创，遍历比较）： 执行结果 用量 排名 用时 20 ms 超过100 %用户 内存 10.5 MB 超过5.15%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { stack&lt;TreeNode*&gt; pStack; stack&lt;TreeNode*&gt; qStack; while((p || !pStack.empty()) &amp;&amp; (q || !qStack.empty())){ int pVal, qVal; if(p &amp;&amp; q){ if(p-&gt;val != q-&gt;val){ return false; } pStack.push(p); p = p-&gt;left; qStack.push(q); q = q-&gt;left; } else if(!p &amp;&amp; !q){ p = pStack.top(); pStack.pop(); p = p-&gt;right; q = qStack.top(); qStack.pop(); q = q-&gt;right; } else{ return false; } } if(p || !pStack.empty() || q || !qStack.empty()) return false; return true; }}; 代码实现（递归比较）： 执行结果 用量 排名 用时 4ms 超过47.59 %用户 内存 9.8 MB 超过96.10 %用户 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if(!p &amp;&amp; !q) return true; if(!p &amp;&amp; q || p &amp;&amp; !q) return false; if(p-&gt;val != q-&gt;val) return false; if(!isSameTree(p-&gt;left, q-&gt;left)) return false; return isSameTree(p-&gt;right, q-&gt;right); }};","link":"/2020/08/05/LeetCode-Dairy-XXI/"},{"title":"LeetCode Dairy XXII","text":"对称二叉树 No.101题目描述：给定一个二叉树，检查它是否是镜像对称的。 代码实现（原创，递归）： 执行结果 用量 排名 用时 8 ms 超过47.24 %用户 内存 12.3 MB 超过91.99 %用户 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(!root) return true; return toVerify(root-&gt;left, root-&gt;right); } bool toVerify(TreeNode* a, TreeNode* b){ if(!a &amp;&amp; !b) return true; if(!a &amp;&amp; b || a &amp;&amp; !b) return false; if(a-&gt;val != b-&gt;val) return false; if(!toVerify(a-&gt;left, b-&gt;right)) return false; return toVerify(a-&gt;right, b-&gt;left); }}; 代码实现（原创，双指针同时反向遍历比较）： 执行结果 用量 排名 用时 4 ms 超过87.45 %用户 内存 12.9 MB 超过6.44 %用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { TreeNode* p = root; TreeNode* q = root; stack&lt;TreeNode*&gt; pStack; stack&lt;TreeNode*&gt; qStack; while((p || !pStack.empty()) &amp;&amp; (q || !qStack.empty())){ if(p &amp;&amp; q){ if(p-&gt;val != q-&gt;val) return false; pStack.push(p); p = p-&gt;left; qStack.push(q); q = q-&gt;right; } else if(!p &amp;&amp; !q){ p = pStack.top(); pStack.pop(); p = p-&gt;right; q = qStack.top(); qStack.pop(); q = q-&gt;left; } else{ return false; } } if(p || q || !pStack.empty() || !qStack.empty()){ return false; } return true; }}; 二叉树的层序遍历 NO.102题目描述：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 代码实现（原创）： 执行结果 用量 排名 用时 12 ms 超过10.94 %用户 内存 11.8 MB 超过45.70 %用户 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;TreeNode*&gt; upNode; if(!root){ return ret; } ret.push_back({root-&gt;val}); upNode.push_back(root); while(!upNode.empty()){ vector&lt;int&gt; valTemp; vector&lt;TreeNode*&gt; nodeTemp; for(TreeNode* node : upNode){ if(node-&gt;left) { nodeTemp.push_back(node-&gt;left); valTemp.push_back(node-&gt;left-&gt;val); } if(node-&gt;right){ nodeTemp.push_back(node-&gt;right); valTemp.push_back(node-&gt;right-&gt;val); } } if(nodeTemp.empty()) break; upNode = nodeTemp; ret.push_back(valTemp); } return ret; }};","link":"/2020/08/06/LeetCode-Dairy-XXII/"},{"title":"LeetCode Dairy XXIX","text":"只出现一次的数字 II NO.137题目描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 代码实现（掩码）： 执行结果 用量 排名 用时 12 ms 超过94.21%用户 内存 9.1 MB 超过97.31%用户 123456789101112class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int a = 0; int b = 0; for(int num : nums){ a = (a ^ num) &amp; ~b; b = (b ^ num) &amp; ~a; } return a; }}; LRU缓存机制 NO.146题目描述：运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 代码实现（使用容器list和unordered_map）： 执行结果 用量 排名 用时 196 ms 超过74.14%用户 内存 37.2 MB 超过70.87%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344class LRUCache {public: int capacityMax; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; mark; list&lt;pair&lt;int, int&gt;&gt; store; LRUCache(int capacity) { capacityMax = capacity; } int get(int key) { auto itr = mark.find(key); if(itr != mark.end()){ store.splice(store.begin(), store, itr-&gt;second); return itr-&gt;second-&gt;second; } else{ return -1; } } void put(int key, int value) { auto itr = mark.find(key); if(itr != mark.end()){ store.splice(store.begin(), store, itr-&gt;second); itr-&gt;second-&gt;second = value; } else{ store.emplace_front(key, value); mark[key] = store.begin(); } if(mark.size() &gt; capacityMax){ int oldest = store.back().first; store.pop_back(); mark.erase(oldest); } }};/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 代码实现（实现双向链表，前后伪节点）： 执行结果 用量 排名 用时 188 ms 超过87.26%用户 内存 37.4 MB 超过42.88%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576struct DoubleLinkedNode{ int key; int value; DoubleLinkedNode* prev; DoubleLinkedNode* next; DoubleLinkedNode(): key(0), value(0), prev(NULL), next(NULL){} DoubleLinkedNode(int _key, int _value): key(_key), value(_value), prev(NULL), next(NULL){} };class LRUCache {private: int capacityMax; unordered_map&lt;int ,DoubleLinkedNode*&gt; mark; DoubleLinkedNode* dummyHead; DoubleLinkedNode* dummyTail;public: LRUCache(int capacity) { capacityMax = capacity; dummyHead = new DoubleLinkedNode(); dummyTail = new DoubleLinkedNode(); dummyHead-&gt;next = dummyTail; dummyTail-&gt;prev = dummyHead; } int get(int key) { auto itr = mark.find(key); if(itr != mark.end()){ removeNode(itr-&gt;second); addToHead(itr-&gt;second); return itr-&gt;second-&gt;value; } else { return -1; } } void put(int key, int value) { auto itr = mark.find(key); if(itr != mark.end()){ removeNode(itr-&gt;second); addToHead(itr-&gt;second); itr-&gt;second-&gt;value = value; } else{ DoubleLinkedNode* temp = new DoubleLinkedNode(key, value); addToHead(temp); mark[key] = temp; if(mark.size() &gt; capacityMax){ DoubleLinkedNode* node = dummyTail-&gt;prev; removeNode(node); mark.erase(node-&gt;key); delete(node); } } } void removeNode(DoubleLinkedNode* node){ node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; } void addToHead(DoubleLinkedNode* node){ node-&gt;prev = dummyHead; node-&gt;next = dummyHead-&gt;next; dummyHead-&gt;next-&gt;prev = node; dummyHead-&gt;next = node; }};/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","link":"/2020/08/17/LeetCode-Dairy-XXIX/"},{"title":"LeetCode Dairy XXX","text":"相交链表 NO.160题目描述：编写一个程序，找到两个单链表相交的起始节点。 代码实现（原创）： 执行结果 用量 排名 用时 60 ms 超过56.91%用户 内存 14.5 MB 超过67.40%用户 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* stepA = headA; ListNode* stepB = headB; while(stepA != stepB){ stepA = stepA ? stepA-&gt;next : headB; stepB = stepB ? stepB-&gt;next : headA; } return stepA; }}; 反转链表 NO.206题目描述：反转一个单链表。 代码实现（记忆，递归）： 执行结果 用量 排名 用时 12 ms 超过72.03%用户 内存 8.9 MB 超过5.01%用户 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if(!head) return NULL; if(!head-&gt;next) return head; ListNode* root = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return root; }}; 代码实现（原创，迭代）： 执行结果 用量 排名 用时 12 ms 超过72.03%用户 内存 8.3 MB 超过94.43%用户 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if(!head) return NULL; ListNode* first = head; ListNode* second = head-&gt;next; while(second){ ListNode* temp = second-&gt;next; second-&gt;next = first; if(first == head) first-&gt;next = NULL; first = second; second = temp; } return first; }}; 删除链表中的节点 NO.237题目描述：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 代码实现（记忆，更改值，无需前驱节点）： 执行结果 用量 排名 用时 20 ms 超过85.95%用户 内存 7.8 MB 超过42.93%用户 1234567891011121314151617/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { ListNode* temp = node-&gt;next; node-&gt;val = temp-&gt;val; node-&gt;next = temp-&gt;next; //delete(temp); }}; 快乐数 NO.202题目描述：编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 代码实现（原创，数字硬编码）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6.0 MB 超过69.15%用户 1234567891011121314class Solution {public: bool isHappy(int n) { while(n != 1 &amp;&amp; n != 4){ int sum = 0; while(n){ sum += pow(n % 10, 2); n = n / 10; } n = sum; } return n == 1; }}; 代码实现（参考环形链表思路）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 5.9 MB 超过73.00%用户 123456789101112131415161718192021class Solution {public: bool isHappy(int n) { int slow = n; int fast = getNext(n); while(slow != fast){ slow = getNext(slow); fast = getNext(getNext(fast)); } return fast == 1; } int getNext(int n){ int sum = 0; while(n){ sum += pow(n % 10, 2); n = n / 10; } return sum; }}; 移除链表元素 NO.203题目描述：删除链表中等于给定值 val 的所有节点。 代码实现（原创，迭代）： 执行结果 用量 排名 用时 44 ms 超过81.42%用户 内存 15.4 MB 超过33.84%用户 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* prev = dummyHead; ListNode* cur = head; while(cur){ ListNode* temp = cur-&gt;next; if(cur-&gt;val == val){ prev-&gt;next = temp; delete(cur); } else{ prev = cur; } cur = temp; } ListNode* ret = dummyHead-&gt;next; delete(dummyHead); return ret; }}; 有效的字母异位词 NO.242题目描述：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 代码实现（原创）： 执行结果 用量 排名 用时 8 ms 超过92.30%用户 内存 7.2 MB 超过99.21%用户 1234567891011121314151617181920class Solution {public: bool isAnagram(string s, string t) { int sSize = s.size(); int tSize = t.size(); if(sSize != tSize) return false; int mark[26] = {0}; for(int i = 0; i &lt; sSize; i++){ mark[s[i] - 'a']++; mark[t[i] - 'a']--; } for(int i = 0; i &lt; 26; i++){ if(mark[i]) return false; } return true; }}; 存在重复元素 NO.217题目描述：给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 代码实现（原创，hash）： 执行结果 用量 排名 用时 76 ms 超过60.08%用户 内存 19.7 MB 超过43.08%用户 1234567891011class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; mark; for(auto num : nums){ if(mark.count(num)) return true; mark[num] = 1; } return false; }}; 代码实现（参考set）： 执行结果 用量 排名 用时 80 ms 超过48.67%用户 内存 19.8 MB 超过33.33%用户 123456class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { return unordered_set&lt;int&gt;(nums.begin(), nums.end()).size() != nums.size(); }}; 存在重复元素 II NO.219题目描述：给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。 代码实现（原创，hash）： 执行结果 用量 排名 用时 48 ms 超过94.53%用户 内存 16.2 MB 超过45.07%用户 1234567891011121314class Solution {public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int ,int&gt; mark; for(int i = 0; i &lt; nums.size(); i++){ if(mark.count(nums[i])){ if(i - mark[nums[i]] &lt;= k) return true; } mark[nums[i]] = i; } return false; }};","link":"/2020/08/18/LeetCode-Dairy-XXX/"},{"title":"LeetCode Dairy XXVI","text":"填充每个节点的下一个右侧节点指针 NO.116题目描述：给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 代码实现（原创，递归）： 执行结果 用量 排名 用时 28 ms 超过89.11%用户 内存 17.2MB 超过46.50%用户 12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(!root) return NULL; if(!root-&gt;left &amp;&amp; !root-&gt;right) return root; Node* left = connect(root-&gt;left); Node* right = connect(root-&gt;right); left-&gt;next = right; while(left-&gt;right){ left-&gt;right-&gt;next = right-&gt;left; left = left-&gt;right; right = right-&gt;left; } return root; }}; 代码实现（递归简化）： 执行结果 用量 排名 用时 16 ms 超过100%用户 内存 16.9 MB 超过74.61%用户 1234567891011121314151617181920212223242526272829303132/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(!root) return NULL; Node* left = connect(root-&gt;left); Node* right = connect(root-&gt;right); while(left){ left-&gt;next = right; left = left-&gt;right; right = right-&gt;left; } return root; }}; 代码实现（原创，迭代）： 执行结果 用量 排名 用时 32 ms 超过72.46%用户 内存 17.1 MB 超过49.36%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(root == nullptr) return nullptr; Node* current = root; Node* head = current; Node* end = current-&gt;left; bool flag = 1; while(end){ while(current){ current-&gt;left-&gt;next = current-&gt;right; if(flag) { flag = 0; head = current-&gt;left; } else{ end-&gt;next = current-&gt;left; } end = current-&gt;right; current = current-&gt;next; } current = head; end = current-&gt;left; flag= 1; } return root; }}; 填充每个节点的下一个右侧节点指针 II NO.117题目描述：给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 代码实现（原创，迭代）： 执行结果 用量 排名 用时 20 ms 超过72.58%用户 内存 17.6 MB 超过62.14%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(root == nullptr) return nullptr; Node* current = root; Node* head = root-&gt;left ? root-&gt;left : root-&gt;right; while(head != nullptr){ Node* end = NULL; head = NULL; while(current){ if(current-&gt;left){ if(end) end-&gt;next = current-&gt;left; else head = current-&gt;left; end = current-&gt;left; } if(current-&gt;right){ if(end) end-&gt;next = current-&gt;right; else head = current-&gt;right; end = current-&gt;right; } current = current-&gt;next; } current = head; } return root; }};","link":"/2020/08/12/LeetCode-Dairy-XXVI/"},{"title":"LeetCode Dairy XXV","text":"平衡二叉树 NO.110题目描述：给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 代码实现（原创）： 执行结果 用量 排名 用时 16 ms 超过69.34 %用户 内存 14.8 MB 超过75.45 %用户 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool result = true; bool isBalanced(TreeNode* root) { toDig(root, 0); return result; } int toDig(TreeNode* root, int deep){ if(!root){ return deep; } int left = toDig(root-&gt;left, deep + 1); int right = toDig(root-&gt;right, deep + 1); if(abs(right - left) &gt; 1) result = false; return max(left, right); }}; 路径总和 NO.112题目描述：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 代码实现（原创）： 执行结果 用量 排名 用时 16 ms 超过53.45 %用户 内存 17.5 MB 超过33.33 %用户 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool hasPathSum(TreeNode* root, int sum) { return toDig(root ,sum, 0); } bool toDig(TreeNode* root, int sum , int current){ if(!root){ return false; } current += root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; current == sum){ return true; } if(toDig(root-&gt;left, sum, current) || toDig(root-&gt;right, sum , current)) return true; return false; }}; 路径总和 II NO.113问题描述：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 代码实现（原创，递归）： 执行结果 用量 排名 用时 12 ms 超过73.29 %用户 内存 16.7 MB 超过99.14 %用户 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; toDig(root, sum, cur, ret); return ret; } void toDig(TreeNode* root, int sum, vector&lt;int&gt;&amp; current,vector&lt;vector&lt;int&gt;&gt;&amp; result){ if(!root){ return; } if(!root-&gt;left &amp;&amp; !root-&gt;right){ if(sum == root-&gt;val){ current.push_back(root-&gt;val); result.push_back(current); current.pop_back(); } return; } current.push_back(root-&gt;val); toDig(root-&gt;left, sum - root-&gt;val, current, result); toDig(root-&gt;right, sum - root-&gt;val, current, result); current.pop_back(); }}; 二叉树展开为链表 NO.114题目描述：给定一个二叉树，原地将它展开为一个单链表。 代码实现（原创，递归）： 执行结果 用量 排名 用时 8 ms 超过72.07 %用户 内存 12 MB 超过82.55 %用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* findRightSon(TreeNode* root){ while(root-&gt;right){ root = root-&gt;right; } return root; } void flatten(TreeNode* root) { toFlatten(root); } TreeNode* toFlatten(TreeNode* root){ if(!root) return NULL; if(!root-&gt;left &amp;&amp; !root-&gt;right){ return root; } TreeNode* left = toFlatten(root-&gt;left); TreeNode* right = toFlatten(root-&gt;right); if(left){ root-&gt;right = left; } else{ root-&gt;right = NULL; } if(right){ TreeNode* end = findRightSon(root); end-&gt;right = right; } root-&gt;left = NULL; return root; }};","link":"/2020/08/11/LeetCode-Dairy-XXV/"},{"title":"LeetCode Dairy XXVIII","text":"验证回文串 NO.125题目描述：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 代码实现（原创，双指针）： 执行结果 用量 排名 用时 12 ms 超过64.20%用户 内存 7.2 MB 超过87.16%用户 1234567891011121314151617181920212223242526class Solution {public: bool isPalindrome(string s) { int sSize = s.size(); if(!sSize) return true; int front = 0; int behind = sSize - 1; while(front &lt; behind){ if(!isalnum(s[front])){ front++; continue; } if(!isalnum(s[behind])){ behind--; continue; } char chFront = tolower(s[front]); char chBehind = tolower(s[behind]); if(chFront != chBehind) return false; front++; behind--; } return true; }}; 只出现一次的数字 NO.136题目描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 代码实现（原创，异或）： 执行结果 用量 排名 用时 20 ms 超过87.11%用户 内存 11.4 MB 超过98.60%用户 1234567int singleNumber(vector&lt;int&gt;&amp; nums) { int ret = 0; for(int i = 0; i &lt; nums.size(); i++){ ret ^= nums[i]; } return ret; } 环形链表 NO.141题目描述：给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 代码实现（原创，快慢指针追赶）： 执行结果 用量 排名 用时 12 ms 超过65.23%用户 内存 7.5 MB 超过97.34%用户 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { if(head == nullptr) return false; ListNode* fast = head; ListNode* slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) return true; } return false; }}; 环形链表 II NO.142题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 代码实现（快慢指针，相遇后，设置指针1指向头，指针2指向相遇点，同时移动，再次相遇，得到答案）： 执行结果 用量 排名 用时 4 ms 超过99.81%用户 内存 7.5 MB 超过83.47%用户 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { if(!head) return NULL; ListNode* fast = head; ListNode* slow = head; ListNode* meet = NULL; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow){ meet = fast; break; } } slow = head; while(meet){ if(slow == meet) return slow; slow = slow-&gt;next; meet = meet-&gt;next; } return NULL; }};","link":"/2020/08/14/LeetCode-Dairy-XXVIII/"},{"title":"LeetCode Dairy XXVII","text":"杨辉三角 NO.118题目描述：给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6.9 MB 超过5.42%用户 123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ret; if(!numRows) return ret; ret.push_back({1}); for(int i = 1; i &lt; numRows; i++){ vector&lt;int&gt; temp; temp.push_back(1); for(int j = 0; j &lt; i - 1; j++){ temp.push_back(ret[i - 1][j] + ret[i - 1][j + 1]); } temp.push_back(1); ret.push_back(temp); } return ret; }}; 杨辉三角 II NO.119题目描述：给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 代码实现（原创）： 执行结果 用量 排名 用时 4 ms 超过41.63 %用户 内存 6.6 MB 超过47.78 %用户 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; ret; ret.push_back(1); if(rowIndex == 0) return ret; ret.push_back(1); if(rowIndex == 1) return ret; for(int i = 2; i &lt;= rowIndex; i++){ int first = ret[0]; int last = ret[1]; for(int j = 1; j &lt; i; j++){ ret[j] = first + last; first = last; if(j + 1 &gt; i - 1) break; last = ret[j + 1]; } ret.push_back(1); } return ret; }}; 代码实现（逆向处理）： 执行结果 用量 排名 用时 0 ms 超过100 %用户 内存 6.5 MB 超过56.84 %用户 1234567891011121314class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; ret; ret.push_back(1); for(int i = 1; i &lt;= rowIndex; i++){ for(int j = i - 1; j &gt; 0; j--){ ret[j] = ret[j] + ret[j - 1]; } ret.push_back(1); } return ret; }}; 买卖股票的最佳时机 NO.121题目描述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 代码实现（原创）： 执行结果 用量 排名 用时 16 ms 超过40.88 %用户 内存 12.8 MB 超过75 %用户 12345678910111213141516171819202122232425class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int pSize = prices.size(); int ret = 0; int minVal ,maxVal; for(int i = 0; i &lt; pSize; i++){ if(i == 0){ minVal = prices[0]; maxVal = prices[0]; continue; } if(prices[i] &lt; minVal){ minVal = prices[i]; maxVal = prices[i]; continue; } if(prices[i] &gt; maxVal){ maxVal = prices[i]; ret = max(maxVal - minVal, ret); } } return ret; }}; 代码实现（优化）： 执行结果 用量 排名 用时 8 ms 超过95.73 %用户 内存 12.9 MB 超过49.52 %用户 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int pSize = prices.size(); int ret = 0; int minVal; for(int i = 0; i &lt; pSize; i++){ if(i == 0){ minVal = prices[0]; continue; } minVal = min(minVal, prices[i]); ret = max(ret, prices[i] - minVal); } return ret; }}; 买卖股票的最佳时机 II NO.122题目描述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 代码实现（原创）： 执行结果 用量 排名 用时 4 ms 超过94.34 %用户 内存 7.2 MB 超过79.63 %用户 123456789101112131415161718192021222324class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int ret = 0; int maxVal; int minVal; for(int i = 0; i &lt; prices.size(); i++){ if(i == 0){ maxVal = prices[0]; minVal = prices[0]; } if(prices[i] &lt; maxVal){ ret += maxVal - minVal; maxVal = prices[i]; minVal = prices[i]; } else{ maxVal = prices[i]; } } if(maxVal == prices[prices.size() - 1]) ret += maxVal - minVal; return ret; }}; 代码实现（贪心）： 执行结果 用量 排名 用时 4 ms 超过94.34 %用户 内存 7.1 MB 超过98.53 %用户 123456789101112class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int ret = 0; for(int i = 0; i &lt; prices.size() - 1; i++){ if(prices[i] &lt; prices[i + 1]){ ret += prices[i + 1] - prices[i]; } } return ret; }}; 三角形最小路径和 NO.120题目描述：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 代码实现（原创）： 执行结果 用量 排名 用时 12 ms 超过46.91%用户 内存 8.2 MB 超过91.01 %用户 123456789101112131415161718192021222324252627class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle){ int tSize = triangle.size(); int ret; if(!tSize) return 0; if(tSize == 1) return triangle[0][0]; for(int i = 1; i &lt; tSize; i++){ for(int j = 0; j &lt; i + 1; j++){ if(j == 0){ triangle[i][0] += triangle[i - 1][0]; } else if(j == i){ triangle[i][i] += triangle[i - 1][i - 1]; } else{ triangle[i][j] += min(triangle[i - 1][j] , triangle[i - 1][j - 1]); } if(i == tSize - 1){ if(j == 0) ret = triangle[i][j]; else ret = min(ret, triangle[i][j]); } } } return ret; }}; 代码实现（空间优化）： 执行结果 用量 排名 用时 8 ms 超过93.24%用户 内存 8.2 MB 超过89.45%用户 123456789101112131415161718class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle){ int tSize = triangle.size(); vector&lt;int&gt; dp(tSize); int ret; if(!tSize) return 0; dp[0] = triangle[0][0]; for(int i = 1; i &lt; tSize; i++){ dp[i] = dp[i - 1] + triangle[i][i]; for(int j = i - 1; j &gt; 0; j--){ dp[j] = min(dp[j] , dp[j - 1]) + triangle[i][j]; } dp[0] = dp[0] + triangle[i][0]; } return *min_element(dp.begin(), dp.end());; }};","link":"/2020/08/13/LeetCode-Dairy-XXVII/"},{"title":"LeetCode Dairy XXXII","text":"移动零 NO.283题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 代码实现（原创，swap接口效率高）： 执行结果 用量 排名 用时 4 ms 超过99.49%用户 内存 8.9 MB 超过81.12%用户 1234567891011121314151617class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int cur = 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i]){ if(cur != i){ // int temp = nums[cur]; // nums[cur] = nums[i]; // nums[i] = temp; swap(nums[cur], nums[i]); } cur++; } } }}; 粉刷房子 NO.256题目描述：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 代码实现（原创，动态规划）： 执行结果 用量 排名 用时 8 ms 超过95.85%用户 内存 9 MB 超过81.25%用户 123456789101112131415class Solution {public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) { int n = costs.size(); if(!n) return 0; int dp[3] = {costs[0][0], costs[0][1], costs[0][2]}; for(int i = 1; i &lt; n; i++){ int temp0 = dp[0], temp1 = dp[1], temp2 = dp[2]; dp[0] = min(temp1, temp2) + costs[i][0]; dp[1] = min(temp0, temp2) + costs[i][1]; dp[2] = min(temp0, temp1) + costs[i][2]; } return *min_element(dp, dp + 3); }}; 中心对称数 NO.246题目描述：中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。 请写一个函数来判断该数字是否是中心对称数，其输入将会以一个字符串的形式来表达数字。 代码实现（原创，hash）： 执行结果 用量 排名 用时 4 ms 超过16.92%用户 内存 6 MB 超过72.41%用户 12345678910111213141516171819202122class Solution {public: bool isStrobogrammatic(string num) { int nSize = num.size(); int p = 0, q = nSize - 1; unordered_map&lt;char, char&gt; mapping; mapping['0'] = '0'; mapping['1'] = '1'; mapping['6'] = '9'; mapping['8'] = '8'; mapping['9'] = '6'; while(p &lt;= q){ if(!mapping.count(num[p]) || !mapping.count(num[q])) return false; if(num[p] != mapping[num[q]]) return false; p++; q--; } return true; }}; 代码实现（原创，if判断）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过77.59%用户 12345678910111213141516171819class Solution {public: bool isStrobogrammatic(string num) { int nSize = num.size(); int p = 0, q = nSize - 1; while(p &lt;= q){ bool judge = (num[p] == '0' &amp;&amp; num[q] == '0') || (num[p] == '1' &amp;&amp; num[q] == '1') || (num[p] == '6' &amp;&amp; num[q] == '9') || (num[p] == '8' &amp;&amp; num[q] == '8') || (num[p] == '9' &amp;&amp; num[q] == '6'); if(!judge) return false; p++; q--; } return true; }}; 同构字符串 NO.205题目描述：给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 代码实现（原创，双hash）： 执行结果 用量 排名 用时 20 ms 超过40.48%用户 内存 7.1 MB 超过68.12%用户 1234567891011121314151617181920class Solution {public: bool isIsomorphic(string s, string t) { int sSize = s.size(); if(!sSize) return true; unordered_map&lt;char, char&gt; markS; unordered_map&lt;char, char&gt; markT; for(int i = 0; i &lt; sSize; i++){ if(markS.count(s[i]) &amp;&amp; markT.count(t[i])){ if(markS[s[i]] != markT[t[i]]) return false; } else if(!markS.count(s[i]) &amp;&amp; !markT.count(t[i])){ markS[s[i]] = i; markT[t[i]] = i; } else return false; } return true; }}; 代码实现（优化hash）： 执行结果 用量 排名 用时 4 ms 超过99.36%用户 内存 6.9 MB 超过88.42%用户 12345678910111213141516171819class Solution {public: bool isIsomorphic(string s, string t) { int sSize = s.size(); if(!sSize) return true; int markS[128] = {0}; int markT[128] = {0}; for(int i = 0; i &lt; sSize; i++){ if(markS[s[i]] != markT[t[i]]) return false; else{ if(!markS[s[i]]){ markS[s[i]] = i + 1; markT[t[i]] = i + 1; } } } return true; }}; 最短单词距离 NO.243题目描述：给定一个单词列表和两个单词 word1 和 word2，返回列表中这两个单词之间的最短距离。 代码实现（原创）： 执行结果 用量 排名 用时 20 ms 超过84.29%用户 内存 10.4 MB 超过92.06%用户 123456789101112131415161718192021222324class Solution {public: int shortestDistance(vector&lt;string&gt;&amp; words, string word1, string word2) { int wSize = words.size(); int minDis = wSize; int left = -1; int right = -1; for(int i = 0; i &lt; wSize; i++){ if(words[i] == word1){ left = i; if(right &gt;= 0){ minDis = min(minDis, abs(left - right)); } } else if(words[i] == word2){ right = i; if(left &gt;= 0){ minDis = min(minDis, abs(left - right)); } } } return minDis; }}; 各位相加 NO.258题目描述：给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 代码实现（原创，暴力法）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过14.80%用户 1234567891011121314class Solution {public: int addDigits(int num) { while(num &gt; 9){ int sum = 0; while(num){ sum += num % 10; num /= 10; } num = sum; } return num; }}; 代码实现（技巧，x100+y10+z=x99+y9+x+y+z）： 执行结果 用量 排名 用时 4 ms 超过46.58%用户 内存 6 MB 超过30.51%用户 123456class Solution {public: int addDigits(int num) { return (num - 1) % 9 + 1; }};","link":"/2020/08/20/LeetCode-Dairy-XXXII/"},{"title":"LeetCode Dairy XXXIII","text":"会议室 NO.252题目描述：给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，请你判断一个人是否能够参加这里面的全部会议。 代码实现（原创）： 执行结果 用量 排名 用时 48 ms 超过43.54%用户 内存 10.7MB 超过90.58%用户 12345678910111213141516171819class Solution {public: bool canAttendMeetings(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { int iSize = intervals.size(); if(!iSize) return true; if(iSize == 1) return true; sort(intervals.begin(), intervals.end()); int left = intervals[0][0]; int right = intervals[0][1]; for(int i = 1; i &lt; iSize; i++){ if(right &gt; intervals[i][0]) return false; left = intervals[i][0]; right = intervals[i][1]; } return true; }}; 计数质数 NO.204题目描述：统计所有小于非负整数 n 的质数的数量。 代码实现（参考暴力法）： 执行结果 用量 排名 用时 560 ms 超过19.30%用户 内存 5.9 MB 超过92.47%用户 1234567891011121314151617class Solution {public: int countPrimes(int n) { int count = 0; for(int i = 2; i &lt; n; i++){ bool flag = true; for(int j = 2; j * j &lt;= i; j++){ if(i % j == 0) { flag = false; break; } } if(flag) count++; } return count; }}; 代码实现（埃拉托色尼筛选）: 执行结果 用量 排名 用时 196 ms 超过64.69%用户 内存 6.5 MB 超过55.07%用户 12345678910111213141516171819class Solution {public: int countPrimes(int n) { int count = 0; vector&lt;bool&gt; judge(n, true); for(int i = 2; i * i &lt;= n; i++){ if(judge[i]){ for(int j = i * i; j &lt; n;j += i){ judge[j] = false; } } } for(int i = 2; i &lt; n; i++){ if(judge[i]) count++; } return count; }};","link":"/2020/08/22/LeetCode-Dairy-XXXIII/"},{"title":"LeetCode Dairy XXXIV","text":"单词规律 NO.290题目描述：给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 代码实现（原创）： 执行结果 用量 排名 用时 4 ms 超过45%用户 内存 6.4 MB 超过88.07%用户 123456789101112131415161718192021222324252627282930313233class Solution {public: bool wordPattern(string pattern, string str) { int pSize = pattern.size(); int sSize = str.size(); int patternMap[26] = {0}; unordered_map&lt;string, int&gt; strMap; str.push_back(' '); string cur = \"\"; int index = 0; for(int i = 0; i &lt; sSize + 1; i++){ if(index &gt; pSize - 1) return false; if(str[i] == ' '){ if(!strMap.count(cur)){ if(patternMap[pattern[index] - 'a'] == 0){ strMap[cur] = index + 1; patternMap[pattern[index] - 'a'] = index + 1; } else return false; } else if(strMap[cur] != patternMap[pattern[index] - 'a']) return false; cur = \"\"; index++; } else cur += str[i]; } if(index != pSize) return false; return true; }}; 丑数 NO.263题目描述：编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100.00%用户 内存 6.1 MB 超过8.39%用户 12345678910111213141516171819class Solution {public: bool isUgly(int num) { if(!num) return false; while(num != 1){ if(num % 2 == 0){ num /= 2; } else if(num % 3 == 0){ num /= 3; } else if(num % 5 == 0){ num /= 5; } else return false; } return true; }}; Nim游戏 NO.292题目描述：你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 代码实现（原创）： 执行结果 用量 排名 用时 0 ms 超过100.00%用户 内存 6.1 MB 超过5.13%用户 123456class Solution {public: bool canWinNim(int n) { return n % 4 != 0; }}; 猜数字游戏 NO.299题目描述：你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 你写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。朋友根据提示继续猜，直到猜出秘密数字。请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。 xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。 代码实现（原创）： 执行结果 用量 排名 用时 4 ms 超过93.62%用户 内存 6.6 MB 超过95.07%用户 1234567891011121314151617181920212223class Solution {public: string getHint(string secret, string guess) { int sSize = secret.size(); int bulls = 0; int cows = 0; int numMap[10] = {0}; for(int i = 0; i &lt; sSize; i++){ if(secret[i] == guess[i]){ bulls++; } else{ if(numMap[secret[i] - '0'] &lt; 0) cows++; if(numMap[guess[i] - '0'] &gt; 0) cows++; numMap[secret[i] - '0']++; numMap[guess[i] - '0']--; } } string ret = to_string(bulls) + \"A\" + to_string(cows) +\"B\"; return ret; }};","link":"/2020/08/23/LeetCode-Dairy-XXXIV/"},{"title":"LeetCode Dairy XXXI","text":"用队列实现栈 NO.225题目描述：使用队列实现栈的下列操作： push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 代码实现（单队列）： 执行结果 用量 排名 用时 4 ms 超过38.12%用户 内存 6.9 MB 超过74.86%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MyStack {private: queue&lt;int&gt; q;public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { int qSize = q.size(); q.push(x); while(qSize--){ int temp = q.front(); q.pop(); q.push(temp); } } /** Removes the element on top of the stack and returns that element. */ int pop() { int ret = q.front(); q.pop(); return ret; } /** Get the top element. */ int top() { return q.front(); } /** Returns whether the stack is empty. */ bool empty() { return q.empty(); }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 代码实现（双队列）： 执行结果 用量 排名 用时 4 ms 超过38.12%用户 内存 7.1 MB 超过20.61%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyStack {private: queue&lt;int&gt; q1; queue&lt;int&gt; q2;public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { int size1 = q1.size(); q2.push(x); while(size1--){ q2.push(q1.front()); q1.pop(); } queue&lt;int&gt; temp = q1; q1 = q2; q2 = temp; return; } /** Removes the element on top of the stack and returns that element. */ int pop() { int ret = q1.front(); q1.pop(); return ret; } /** Get the top element. */ int top() { return q1.front(); } /** Returns whether the stack is empty. */ bool empty() { return q1.empty(); }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 用栈实现队列 NO.232题目描述：使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 代码实现（双栈）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.1 MB 超过29.62%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyQueue {public: /** Initialize your data structure here. */ stack&lt;int&gt; s1; stack&lt;int&gt; s2; MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { int size1 = s1.size(); int size2 = size1; while(size1--){ s2.push(s1.top()); s1.pop(); } s1.push(x); while(size2--){ s1.push(s2.top()); s2.pop(); } } /** Removes the element from in front of queue and returns that element. */ int pop() { int ret = s1.top(); s1.pop(); return ret; } /** Get the front element. */ int peek() { return s1.top(); } /** Returns whether the queue is empty. */ bool empty() { return s1.empty(); }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 代码实现（双栈优化）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 7.1 MB 超过27.87%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MyQueue {public: /** Initialize your data structure here. */ stack&lt;int&gt; s1; stack&lt;int&gt; s2; int front; MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { if(s1.empty()){ front = x; } s1.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { if(s2.empty()){ while(!s1.empty()){ s2.push(s1.top()); s1.pop(); } } int ret = s2.top(); s2.pop(); return ret; } /** Get the front element. */ int peek() { if(!s2.empty()){ return s2.top(); } return front; } /** Returns whether the queue is empty. */ bool empty() { return s1.empty() &amp;&amp; s2.empty(); }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 2的幂 NO.231题目描述：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 代码实现（取余）： 执行结果 用量 排名 用时 4 ms 超过42.56%用户 内存 6 MB 超过37.07%用户 12345678910class Solution {public: bool isPowerOfTwo(int n) { if(n &lt;= 0) return false; while(n % 2 == 0){ n = n / 2; } return n == 1; }}; 代码实现（位运算）： 执行结果 用量 排名 用时 0 ms 超过100%用户 内存 6 MB 超过18.53%用户 12345678class Solution {public: bool isPowerOfTwo(int n) { if(n &lt;= 0) return false; long x = n; return (x &amp; (x - 1)) == 0; }}; 回文链表 NO.234题目描述：请判断一个链表是否为回文链表。 代码实现（逆转一半链表）： 执行结果 用量 排名 用时 32 ms 超过74.09%用户 内存 13.9 MB 超过67.42%用户 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { if(!head) return true; ListNode* prev = NULL; ListNode* slow = head; ListNode* fast = head-&gt;next; while(fast &amp;&amp; fast-&gt;next){ slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } slow = slow-&gt;next; while(slow){ ListNode* temp = slow-&gt;next; slow-&gt;next = prev; prev = slow; slow = temp; } ListNode* p = head; while(prev){ if(prev-&gt;val != p-&gt;val) return false; prev = prev-&gt;next; p = p-&gt;next; } return true; }};","link":"/2020/08/19/LeetCode-Dairy-XXXI/"},{"title":"LeetCode Dairy XXXV","text":"对链表进行插入排序 NO.147题目描述：对链表进行插入排序。 代码实现（原创）： 执行结果 用量 排名 用时 60 ms 超过20.13%用户 内存 9.7 MB 超过99.64%用户 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* insertionSortList(ListNode* head) { if(!head || !head-&gt;next) return head; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* cur = head-&gt;next; head-&gt;next = NULL; while(cur){ ListNode* prev = dummyHead; ListNode* cursor = dummyHead-&gt;next; ListNode* temp = cur-&gt;next; bool flag = false; while(cursor){ if(cur-&gt;val &lt; cursor-&gt;val){ prev-&gt;next = cur; cur-&gt;next = cursor; flag = true; break; } prev = prev-&gt;next; cursor = cursor-&gt;next; } if(!flag){ prev-&gt;next = cur; cur-&gt;next = NULL; } cur = temp; } ListNode* ret = dummyHead-&gt;next; delete(dummyHead); return ret; }}; 代码实现（简化版）： 执行结果 用量 排名 用时 24 ms 超过95.86%用户 内存 9.8 MB 超过53.31%用户 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* insertionSortList(ListNode* head) { if(!head || !head-&gt;next) return head; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* tail = head; ListNode* cur = head-&gt;next; while(cur){ if(cur-&gt;val &lt; tail-&gt;val){ ListNode* temp = dummyHead; while(temp-&gt;next-&gt;val &lt; cur-&gt;val) temp = temp-&gt;next; tail-&gt;next = cur-&gt;next; cur-&gt;next = temp-&gt;next; temp-&gt;next = cur; cur = tail-&gt;next; } else{ tail = cur; cur = cur-&gt;next; } } ListNode* ret = dummyHead-&gt;next; delete(dummyHead); return ret; }}; 排序链表 NO.148题目描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 代码实现（原创，快排）： 执行结果 用量 排名 用时 1796 ms 超过5%用户 内存 17.3 MB 超过42.04%用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { ListNode* dummyHead = new ListNode(-1); dummyHead-&gt;next = head; quickSortHelper(dummyHead, NULL); return dummyHead-&gt;next; } void quickSortHelper(ListNode* head, ListNode* tail){ if(!head-&gt;next){ return; } if(head-&gt;next == tail){ return; } ListNode* dummyh = head; ListNode* rhead = head-&gt;next; ListNode* prev = rhead; ListNode* cur = rhead-&gt;next; while(cur != tail &amp;&amp; cur != NULL){ ListNode* temp = cur-&gt;next; if(cur-&gt;val &lt; rhead-&gt;val){ cur-&gt;next = rhead; rhead = cur; dummyh-&gt;next = rhead; prev-&gt;next = temp; } else{ prev = prev-&gt;next; } cur = temp; } quickSortHelper(rhead, NULL); quickSortHelper(dummyh, rhead); }}; 代码实现（参考归并排序，迭代）： 执行结果 用量 排名 用时 72 ms 超过79.58%用户 内存 17.3 MB 超过42.04%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; auto p = head; int count = 0; while(p){ p = p-&gt;next; count++; } for(int i = 1; i &lt; count; i *= 2){ auto cur = dummyHead-&gt;next; auto tail = dummyHead; while(cur){ auto left = cur; auto right = cut(left, i); cur = cut(right, i); tail-&gt;next = mergeList(left, right); while(tail-&gt;next){ tail = tail-&gt;next; } } } return dummyHead-&gt;next; } ListNode* cut(ListNode* head, int length){ ListNode* cur = head; while(--length &amp;&amp; cur) cur = cur-&gt;next; if(!cur) return NULL; ListNode* ret = cur-&gt;next; cur-&gt;next = NULL; return ret; } ListNode* mergeList(ListNode* a, ListNode* b){ ListNode* head = new ListNode(0); ListNode* c = head; while(a &amp;&amp; b){ if(a-&gt;val &lt; b-&gt;val){ c-&gt;next = a; a = a-&gt;next; c = c-&gt;next; } else{ c-&gt;next = b; b = b-&gt;next; c = c-&gt;next; } } if(a) c-&gt;next = a; if(b) c-&gt;next = b; ListNode* ret = head-&gt;next; delete(head); return ret; }}; 代码实现（参考归并排序，递归）： 执行结果 用量 排名 用时 68 ms 超过90.66%用户 内存 16.6 MB 超过55.41%用户 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { if(!head || !head-&gt;next) return head; ListNode* slow = head; ListNode* fast = head-&gt;next; while(fast &amp;&amp; fast-&gt;next){ slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } auto left = head; auto right = slow-&gt;next; slow-&gt;next = NULL; return mergeList(sortList(left), sortList(right)); } ListNode* mergeList(ListNode* l1, ListNode* l2){ if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt;= l2-&gt;val){ l1-&gt;next = mergeList(l1-&gt;next, l2); return l1; } else{ l2-&gt;next = mergeList(l2-&gt;next, l1); return l2; } }}; 两数之和 II - 输入有序数组 NO.167题目描述：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 代码实现（原创，双指针）： 执行结果 用量 排名 用时 12 ms 超过63.32%用户 内存 9.6 MB 超过49.84%用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { vector&lt;int&gt; ret; int nSize = numbers.size(); int left = 0; int right = nSize - 1; while(left &lt; right){ int sum = numbers[left] + numbers[right]; if(sum == target){ ret.push_back(left + 1); ret.push_back(right + 1); return ret; } if(sum &gt; target){ right--; } else{ left++; } } return ret; }};","link":"/2020/08/24/LeetCode-Dairy-XXXV/"},{"title":"LeetCode Dairy XXXVI","text":"多数元素 NO.169题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 代码实现（参考投票法）： 执行结果 用量 排名 用时 20ms 超过76.42%用户 内存 8.7MB 超过81.45%用户 1234567891011121314151617class Solution {public: int majorityElement(vector&lt;int&gt;&amp; nums) { int candidate = 0, count = 0; for(auto num : nums){ if(!count){ candidate = num; count++; } else{ if(num == candidate) count++; else count--; } } return candidate; }}; 代码实现（原创，排序）： 执行结果 用量 排名 用时 60ms 超过11%用户 内存 8.9MB 超过7%用户 1234567class Solution {public: int majorityElement(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); return nums[nums.size()/2]; }};","link":"/2020/08/26/LeetCode-Dairy-XXXVI/"},{"title":"LeetCode Dairy XXXVII","text":"最小栈 NO.155题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 代码实现（参考使用pair）： 执行结果 用量 排名 用时 56 ms 超过20.40%用户 内存 14.5 MB 超过71.22%用户 1234567891011121314151617181920212223242526272829303132333435363738class MinStack {public: /** initialize your data structure here. */ stack&lt;pair&lt;int, int&gt;&gt; store; MinStack() { } void push(int x) { int minVal; if(store.size()){ minVal = min(store.top().second, x); } else minVal = x; store.push(pair(x, minVal)); } void pop() { store.pop(); } int top() { return store.top().first; } int getMin() { return store.top().second; }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 代码实现（参考辅助栈）： 执行结果 用量 排名 用时 44 ms 超过 77.7%用户 内存 14.8 MB 超过 14.75%用户 123456789101112131415161718192021222324252627282930313233343536class MinStack {public: stack&lt;int&gt; store; stack&lt;int&gt; minStore; /** initialize your data structure here. */ MinStack() { minStore.push(INT_MAX); } void push(int x) { store.push(x); if(x &lt;= minStore.top()) minStore.push(x); } void pop() { if(store.top() == minStore.top()) minStore.pop(); store.pop(); } int top() { return store.top(); } int getMin() { return minStore.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 单词接龙 NO.127题目描述：给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 代码实现（参考预处理，广度优先遍历bfs）： 执行结果 用量 排名 用时 356 ms 超过 38%用户 内存 46.7 MB 超过 2.04%用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: unordered_map&lt;string, vector&lt;string&gt;&gt; preHandle; unordered_map&lt;string, bool&gt; visited; int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { int wSize = wordList.size(); if(!wSize) return 0; int len = wordList[0].size(); queue&lt;string&gt; elements; elements.push(beginWord); int level = 1; for(auto word : wordList){ for(int i = 0; i &lt; len; i++){ string newWord = word.substr(0, i) + \"*\" + word.substr(i + 1, len); vector&lt;string&gt; strList; if(preHandle.count(newWord)) strList = preHandle[newWord]; strList.push_back(word); preHandle[newWord] = strList; } } while(!elements.empty()){ int eSize = elements.size(); for(int i = 0; i &lt; eSize; i++){ string word = elements.front(); elements.pop(); for(int j = 0; j &lt; len; j++){ string newWord = word.substr(0, j) + \"*\" + word.substr(j + 1, len); if(preHandle.count(newWord)){ auto strList = preHandle[newWord]; for(auto str : strList){ if(!visited.count(str)){ if(str == endWord) return ++level; elements.push(str); visited[str] = 1; } } } } } level++; } return 0; }}; 代码实现（参考双向广度遍历）： 执行结果 用量 排名 用时 252 ms 超过 50.29%用户 内存 37.4 MB 超过 5.04%用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: unordered_map&lt;string, vector&lt;string&gt;&gt; preHandle; int len; int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { int wSize = wordList.size(); if(!wSize) return 0; len = wordList[0].size(); unordered_map&lt;string, int&gt; beginVisited; beginVisited[beginWord] = 1; unordered_map&lt;string, int&gt; endVisited; endVisited[endWord] = 1; queue&lt;pair&lt;string, int&gt;&gt; beginElements; queue&lt;pair&lt;string, int&gt;&gt; endElements; beginElements.push(pair(beginWord, 1)); endElements.push(pair(endWord, 1)); int flag = 0; for(auto word : wordList){ if(word == endWord) flag = 1; for(int i = 0; i &lt; len; i++){ string newWord = word.substr(0, i) + \"*\" + word.substr(i + 1, len); vector&lt;string&gt; strList; if(preHandle.count(newWord)) strList = preHandle[newWord]; strList.push_back(word); preHandle[newWord] = strList; } } if(!flag) return 0; while(!beginElements.empty() &amp;&amp; !endElements.empty()){ int ans = bfs(beginElements, beginVisited, endVisited); if(ans &gt; -1) return ans; ans = bfs(endElements, endVisited, beginVisited); if(ans &gt; -1) return ans; } return 0; } int bfs(queue&lt;pair&lt;string, int&gt;&gt;&amp; elements, unordered_map&lt;string, int&gt;&amp; ownVisited, unordered_map&lt;string, int&gt;&amp; otherVisited){ string word = elements.front().first; int level = elements.front().second; elements.pop(); for(int j = 0; j &lt; len; j++){ string newWord = word.substr(0, j) + \"*\" + word.substr(j + 1, len); if(preHandle.count(newWord)){ auto strList = preHandle[newWord]; for(auto str : strList){ if(otherVisited.count(str)) return level + otherVisited[str]; if(!ownVisited.count(str)){ elements.push(pair(str, level + 1)); ownVisited[str] = level + 1; } } } } return -1; }};","link":"/2020/08/29/LeetCode-Dairy-XXXVII/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"hard","slug":"hard","link":"/tags/hard/"}],"categories":[{"name":"game","slug":"game","link":"/categories/game/"},{"name":"tech","slug":"tech","link":"/categories/tech/"}]}